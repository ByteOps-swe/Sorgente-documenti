\subsection{Verifica}\label{sec:verifica}
\subsubsection{Introduzione}
Nel processo di sviluppo, lo scopo dell'attività di verifica è quello di garantire la qualità del prodotto attraverso un'analisi accurata e sistematica.

Questo processo coinvolge la revisione e la valutazione delle fasi di sviluppo del codice sorgente e della documentazione, per identificare e correggere errori, difetti o discrepanze rispetto ai requisiti specificati.

Il processo di verifica viene eseguito su tutti i processi in esecuzione al raggiungimento di un livello di maturità adeguato o in seguito a modifiche dello stato del processo. Per i processi di supporto, si analizza la qualità dei prodotti generati e dei processi utilizzati al fine di garantire la conformità agli standard di qualità definiti.
Le attività relative al processo di verifica vengono assegnate ai verificatori, incaricati di analizzare i prodotti e valutarne la conformità ai vincoli qualitativi specificati nel Piano di Qualifica. Tali operazioni seguono l'ordine specificato nel modello a V.
Nel Piano di Qualifica sono documentate tutte le attività che compongono il processo, descrivendone scopi, risultati sperati e risultati ottenuti. Questo fornisce linee guida per una corretta valutazione della qualità, normando e rendendo ripetibile il processo.

La verifica mira a garantire che il software soddisfi gli standard di qualità prestabiliti, riducendo il rischio di errori e migliorando l'affidabilità, la robustezza e l'efficienza del prodotto finale.
Questo processo verrà attuato per ciascuna attività e dovrà assicurare che l'output di quest'ultima sia in uno stato stabile, consentendo così l'inizio della successiva fase di validazione.

\subsubsection{Verifica dei documenti}\label{sec:verificatori}

Il ruolo del verificatore nei documenti è cruciale per garantire la qualità e l'accuratezza del contenuto.

Quando il verificatore individua un'Issue nella colonna "Da revisionare" della \href{https://github.com/orgs/ByteOps-swe/projects/1/views/1}{DashBoard documentazione}, sarà tenuto a convalidare il file corrispondente presente nella repository "Sorgente documenti". \\
In aggiunta, il revisore riceverà una notifica via email quando il redattore completa la propria attività, comunicandogli la presenza della pull request assegnatagli.\\
Nella sezione "pull request" di GitHub, il revisore troverà la richiesta di unire il branch di redazione al branch "main", assumendo il ruolo di revisore. Accedendo alla pull request su GitHub, il revisore avrà la possibilità di esaminare attentamente il documento in questione e di aggiungere commenti visibili ai redattori nel caso in cui siano necessarie modifiche per la validazione.

\vspace{0.3cm}

Per validare un documento le verifiche da attuare sono:
\begin{itemize}
    \item \textbf{Revisione della correttezza tecnica:} 
        eseguire una revisione tecnica del documento per garantire che tutte le informazioni siano corrette, coerenti e rispettino le norme stabilite;
    \item \textbf{Conformità alle norme:} 
        verificare che il documento segua le linee guida e gli standard prestabiliti per la formattazione, la struttura e lo stile;
    \item \textbf{Consistenza e coerenza:} 
        assicurarsi che il documento sia consistente internamente e coerente con altri documenti correlati. Verificare che non ci siano discrepanze o contraddizioni;
    \item \textbf{Chiarezza e comprensibilità:} 
        valutare la chiarezza del testo, assicurandosi che il linguaggio sia comprensibile per il pubblico di destinazione e che non ci siano ambiguità;
    \item \textbf{Revisione grammaticale e ortografica:} 
        controllare la grammatica, l'ortografia e la punteggiatura del documento per garantire una presentazione professionale;
\end{itemize}

Dopo l'attuazione dei controlli sopra citati e aver verificato che siano stati adeguatamenti rispettati, i passi per convalidare il documento sono i seguenti:

\begin{enumerate}
    \item \textbf{Accetta la Pull Request:} 
        accedere alla pagina della pull request in cui si agirà con il ruolo di revisore nel repository "Sorgente documenti" su GitHub >> Risolvere eventuali conflitti >> Merge Pull Request.
    \item \textbf{Elimina il branch:} 
        eliminare il branch creato per la redazione del documento (o sezione).
    \item \textbf{Sposta la issue in Done:} 
        nella \href{https://github.com/orgs/ByteOps-swe/projects/1/views/1}{DashBoard documentazione} spostare la issue relativa al documento validato dalla sezione "Da revisionare" a "Done".
    \item \textbf{Controllo generazione PDF:} 
        un automazione tramite GitHub Actions compilerà il file \LaTeX\ e genererà automaticamente il PDF nel branch main della repository \href{https://github.com/ByteOps-swe/Documents}{Documents} con la data di redazione nel caso il documento sia un verbale, oppure la versione aggiornata per tutte le altre tipologie di file.

        Il verificatore dovrà accedere alla sezione "Actions" di GitHub, supervisionare il processo di compilazione per la possibile generazione di errori, attendere la conclusione del processo di build del codice sorgente e controllare la corretta generazione del documento in formato PDF.
\end{enumerate}

\subsubsection{Analisi}
Attività di controllo su oggetti statici (documentazione, codice) e dinamici (componenti software).

\paragraph{Analisi statica}
Analisi condotta sull'oggetto (documentazione e codice) senza eseguirlo. Si prevede l'impiego di metodi di lettura, sia manuali che automatici, al fine di individuare eventuali errori formali. Le due principali tecniche utilizzate sono:

\paragraph{Walkthrough}
    Il verificatore controllerà nella totalità l’oggetto in cerca di difetti o errori, senza svolgere una ricerca specifica per un certo tipo di errore.
    Questa metodologia implica appunto un'esaminazione approfondita della documentazione e del codice attraverso un'analisi sistematica. Si promuove la collaborazione tra il verificatore e l'autore del prodotto, strutturata nei seguenti quattro passaggi:

\begin{enumerate}
    \item \textbf{Pianificazione:} 
        una fase di dialogo tra gli autori e i verificatori, finalizzata all'identificazione delle proprietà e dei vincoli che il prodotto deve soddisfare per essere considerato corretto;

    \item \textbf{Lettura:} 
        il verificatore esamina attentamente i documenti e/o il codice, individuando errori e verificando la conformità ai vincoli prestabiliti;

    \item \textbf{Discussione:} 
        successivo confronto tra autori e verificatori per discutere l'esito della lettura e valutare eventuali correzioni necessarie;

    \item \textbf{Correzione:} 
        attività assegnata agli autori per correggere gli errori individuati nei passaggi precedenti.
\end{enumerate}

I walkthrough sono più adatti per attività più creative o nelle fasi iniziali del progetto quando la flessibilità e la discussione sono importanti. Sono ideali quando si desidera una comprensione più approfondita e una valutazione qualitativa.

Le attività in cui verrà applicato Walkthrough sono:
\begin{itemize}
    \item \textbf{Revisione dei requisiti:} 
        per assicurarsi che tutti i requisiti siano chiari, comprensibili e conformi alle esigenze del cliente;
    \item \textbf{Codifica del software:} 
        per identificare errori di logica, pratiche non ottimali o potenziali problemi di manutenibilità nel codice;
    \item \textbf{Documentazione tecnica:} 
        per assicurarsi che la documentazione tecnica sia accurata, chiara e completa.
\end{itemize}

\paragraph{Inspection}
L'obiettivo di questa tecnica consiste nel rilevare eventuali difetti nel prodotto oggetto di analisi mediante una lettura mirata, piuttosto che eseguire una revisione completa del codice e della documentazione allegata.

Tale approccio prevede la specifica preventiva degli elementi da verificare, i quali vengono organizzati in liste di controllo.
Queste liste fungono da \textit{checklist} per valutare l'accuratezza dell'attività d'ispezione, determinando se è stata condotta in modo corretto.
L'inspection è più adatta quando i documenti o il codice sono complessi e strutturati. È efficace nelle fasi più avanzate del progetto, quando la stabilità e la completezza sono cruciali.

\paragraph{Analisi dinamica}
Nel ciclo di sviluppo software, è essenziale condurre una verifica accurata del codice prodotto al fine di garantirne il corretto funzionamento. Questo processo si avvale dell'analisi dinamica, una categoria di metodologie che richiedono l'esecuzione effettiva del prodotto.
L'analisi dinamica coinvolge l'esecuzione di una serie di casi di test durante l'attuazione del codice. L'obiettivo di tali test è assicurare l'esecuzione accurata del software e individuare eventuali discordanze tra i risultati ottenuti e quelli previsti.

È importante sottolineare che l'analisi dinamica non è applicabile alla documentazione.
Per assicurare l'efficacia dell'analisi dinamica, è necessario automatizzare e rendere ripetibile questo processo, garantendo così una valutazione oggettiva del prodotto. Nel contesto dell'ingegneria del software, il test rappresenta la principale tecnica di analisi dinamica.

\subsubsection{Testing}
\label{subsec:Testing}
Il testing mira a garantire che la componente soggetta al TEST esegua in modo corretto le attività assegnate e aderisca scrupolosamente ai vincoli ad essa attribuiti. Questi test sono inoltre strumentali per individuare eventuali anomalie di funzionamento.

Per ciascun test, è essenziale definire i seguenti parametri:

\begin{itemize}
    \item \textbf{Ambiente:} 
        il sistema (hardware e software) utilizzato per eseguire il test;
    \item \textbf{Stato iniziale:} 
        i parametri del software al momento dell'esecuzione del test;
    \item \textbf{Input:} 
        i dati forniti in input per l'esecuzione del test;
    \item \textbf{Output:} 
        i risultati attesi in output in relazione a uno specifico input;
    \item \textbf{Commenti addizionali:} 
        eventuali osservazioni o annotazioni aggiuntive pertinenti al test;
\end{itemize}
Tali test andranno poi automatizzati.

\paragraph{Test di unità}
Questi test sono progettati per verificare singole unità di codice, come funzioni o metodi, in modo isolato e indipendente dal resto del sistema. L'obiettivo principale dei test di unità è garantire che ogni unità di codice funzioni correttamente, conformandosi alle specifiche e restituendo i risultati attesi.
Tali test si prestano quindi ad un alto grado di parallelismo, essi vengono pianificati durante la progettazione di dettaglio.
Devono essere eseguiti per primi, in quanto verificano l’integrità e la correttezza della singola unità, prima dell’integrazione con le altre.

Per l'implementazione di tali test è concesso utilizzare oggetti simulati o parziali (mocks e stubs) al fine di separare l'unità di codice in esame dalle sue dipendenze esterne, permettendo così la verifica del suo comportamento in contesti controllati, con l'obiettivo di garantire un'isolamento efficace durante le fasi di test.

Un ulteriore obiettivo dei test di unità consiste nel verificare la massima copertura possibile dei percorsi all'interno dell'unità. A tal fine, vengono appositamente progettati per attivare specifici percorsi, creando così una serie di test dedicati che devono garantire una copertura completa del codice dell'unità, generando in tal modo la "structural coverage".

\paragraph{Test di integrazione}
I test di integrazione sono una fase essenziale nell'analisi dinamica del software e mirano a verificare il corretto funzionamento delle diverse unità di codice quando sono integrate per formare una componente più ampia o l'intero sistema.

Questa fase si concentra sull'interazione tra le parti del software per garantire che lavorino sinergicamente secondo le specifiche del progetto.

I test di integrazione vengono pianificati durante la fase di progettazione architetturale e possono avere un approccio:

\begin{itemize}
    \item \textbf{Top-down:}
        l'integrazione inizia con le componenti di sistema che presentano maggiori dipendenze e un maggiore valore esterno, consentendo la tempestiva disponibilità delle funzionalità di alto livello.

        Ciò consente di effettuare test prolungati sulle funzionalità principali, rendendole disponibili inizialmente ma richiede molti mock;
    \item \textbf{Bottom-up:}
        l'integrazione ha inizio dalle componenti di sistema caratterizzate da minori dipendenze e un maggiore valore interno, ossia quelle meno visibili all'utente. Questo implica la necessità di meno mock ma ritarda il test delle funzionalità utente esponendole per minor tempo a verifica;
\end{itemize}

Il team svolgerà, ove possibile, test di integrazione con l'approccio "Top down".

\paragraph{Test di sistema}
Questi test sono progettati per verificare l'intero sistema software rispetto ai requisiti specificati, garantendo che tutte le componenti siano integrate correttamente e che l'applicazione esegua le funzioni previste in modo accurato e affidabile.

In particolare devono essere implementati:
\begin{itemize}
    \item  \textbf{Test End-to-End:} 
        coinvolgono l'esecuzione completa del sistema, dalla sua interfaccia utente fino alle componenti di backend, al fine di simulare l'esperienza completa dell'utente.
\end{itemize}

I test di sistema vengono eseguiti dopo che sono stati completati con successo i test di integrazione.

\paragraph{Test di regressione}
Mirano a garantire che le modifiche apportate al codice non abbiano introdotto nuovi difetti o compromesso le funzionalità preesistenti del sistema.

Questi test sono essenziali per assicurare che le modifiche al software non causino regressioni, ovvero la ricomparsa di errori precedentemente risolti o la compromissione di funzionalità precedentemente funzionanti.

I test di regressione devono essere eseguiti ogni volta che vengono apportate modifiche al codice, garantendo una verifica continua e automatica della stabilità del sistema.

\paragraph{Test di accettazione}
I test di accettazione sono un passo fondamentale prima del rilascio del software e sono progettati per garantire che il prodotto finale sia in grado di soddisfare le aspettative degli utenti finali e che risponda in modo appropriato ai requisiti specificati.

\paragraph{Sequenza delle fasi di test}
La sequenza delle fasi di test è la seguente:

\begin{enumerate}
    \item Test di Unità.
    \item Test di Integrazione.
    \item Test di Regressione.
    \item Test di Sistema.
    \item Test di accettazione.
\end{enumerate}

\paragraph{Codici dei test}
Per classificare ogni test che il team effettuerà durante l'attività di verifica abbiamo deciso di associare un codice identificativo per ciascun test nel formato:

\begin{center}
    \textbf{T [tipo] [codice]}
\end{center}

dove:

\begin{itemize}
    \item \textbf{[tipo]:} 
        è il tipo di test;
        \begin{itemize}
            \item \textbf{U:} 
                per i test di unità;
            \item \textbf{I:} 
                per i test di integrazione;
            \item \textbf{S:} 
                per i test di sistema;
            \item \textbf{R:} 
                per i test di regressione;
            \item\textbf{A:} 
                per i test di accettazione;
        \end{itemize}
    \item \textbf{[codice]:} 
        è un numero associato al test all'interno del suo tipo:
        \begin{itemize}
            \item 
                se il test non ha un padre, è un semplice numero progressivo;
            \item 
                se il test ha un padre, sarà nel formato:
                \begin{center}
                    \textbf{[codice.padre] . [codice.figlio]}
                \end{center}
                con:
                \begin{itemize}
                    \item \textbf{[codice.padre] :} 
                        identifica in maniera univoca il padre del test all'interno della categoria di test relativi al suo tipo;
                    \item \textbf{[codice.figlio] :} 
                        numero progressivo per identificare il test;
                \end{itemize}
        \end{itemize}
\end{itemize}

\paragraph{Stato dei test}
Ad ogni test verrà successivamente attribuito uno stato che rappresenterà il risultato dell'esecuzione. L'insieme dei risultati dei test sarà registrato nel "cruscotto test".

I test nel cruscotto potranno assumere i seguenti stati:

\begin{itemize}
    \item \textbf{NI:} 
        il test non è ancora stato implementato (Non implementato);
    \item \textbf{S:} 
        il test ha riportato esito positivo (Superato);
    \item \textbf{NS:}
        il test ha riportato esito negativo (Non Superato);
\end{itemize}

\subsubsection{Strumenti}
\begin{itemize}
    \item \textbf{Spell checker:} 
        controllo ortografico integrato nell’ambiente di lavoro;
    \item \textbf{Modulo "unittest" Python}.
\end{itemize}
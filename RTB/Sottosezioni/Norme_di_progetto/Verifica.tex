\subsection{Verifica}
\label{subsec:verifica}

\subsubsection{Introduzione}
La verifica è un processo essenziale che accompagna l'intero ciclo di vita del software, partendo dalla fase di progettazione fino alla manutenzione. \\
Il suo obiettivo principale è garantire l'efficienza e la correttezza delle attività, istanziando per ciascun prodotto un processo di verifica mirato a garantire risultati conformi alle aspettative. Questo processo si avvale di tecniche di analisi e test per assicurare che i prodotti soddisfino i requisiti specificati. \\
Per assicurare il corretto svolgimento della verifica, è fondamentale seguire alcune linee guida chiave, tra cui l'utilizzo di criteri affidabili e di procedure ben definite. Questo assicura che il prodotto si trovi in uno stato stabile, pronto per passare alla successiva fase di validazione. \\
La verifica viene eseguita su tutti i processi in esecuzione, quando si raggiunge un adeguato livello di maturità o in seguito a modifiche dello stato del processo. Durante questa fase, si analizza la qualità dei prodotti e dei processi utilizzati per garantire la conformità agli standard di qualità definiti. \\
Le attività di verifica sono assegnate a verificatori, i quali, seguendo l'ordine definito nel modello a V, analizzano i prodotti e valutano la loro conformità ai requisiti di qualità specificati nel \textit{Piano di Qualifica}. \\ 
È fondamentale documentare nel \textit{Piano di Qualifica} tutte le attività che compongono il processo di verifica, descrivendone gli obiettivi, i risultati attesi e quelli ottenuti. Questo fornisce linee guida per una valutazione accurata della qualità, normando e rendendo ripetibile il processo di verifica.

\subsubsection{Verifica dei documenti}
\label{sec:verificatori}

Il ruolo del verificatore nei documenti è cruciale per garantire la qualità e l'accuratezza del contenuto.

Quando il verificatore individua un'Issue nella colonna "Da revisionare" della \href{https://github.com/orgs/ByteOps-swe/projects/1/views/1}{DashBoard documentazione}, sarà tenuto a convalidare il file corrispondente presente nella repository \href{https://github.com/ByteOps-swe/Sorgente-documenti}{Sorgente documenti}. \\
In aggiunta, il revisore riceverà una notifica via email quando il redattore completa la propria attività, comunicandogli la presenza della Pull Request assegnatagli.\\
Nella sezione "Pull requests" di GitHub, il revisore troverà la richiesta di unire il branch di redazione al branch "main". Accedendo alla Pull Request su GitHub, il revisore avrà la possibilità di esaminare attentamente il documento in questione. Durante questa revisione, il revisore potrà aggiungere commenti direttamente sul documento, fornendo feedback e suggerimenti ai redattori per eventuali modifiche necessarie per la validazione. I commenti aggiunti saranno visibili ai redattori, consentendo loro di comprendere le richieste di revisione e apportare le modifiche richieste. Questo processo collaborativo facilita il flusso di lavoro di revisione e garantisce la qualità e l'accuratezza del documento finale.

\vspace{0.3cm}

Per validare un documento le verifiche da attuare sono:
\begin{itemize}
    \item \textbf{Revisione della correttezza tecnica:} 
        eseguire una revisione tecnica del documento per garantire che tutte le informazioni siano corrette, coerenti e rispettino le norme stabilite;
    \item \textbf{Conformità alle norme:} 
        verificare che il documento segua le linee guida e gli standard prestabiliti per la formattazione, la struttura e lo stile;
    \item \textbf{Consistenza e coerenza:} 
        assicurarsi che il documento sia consistente internamente e coerente con altri documenti correlati. Verificare che non ci siano discrepanze o contraddizioni;
    \item \textbf{Chiarezza e comprensibilità:} 
        valutare la chiarezza del testo, assicurandosi che il linguaggio sia comprensibile per il pubblico di destinazione e che non ci siano ambiguità;
    \item \textbf{Revisione grammaticale e ortografica:} 
        controllare la grammatica, l'ortografia e la punteggiatura del documento per garantire una presentazione professionale;
\end{itemize}

Dopo aver accertato il rispetto dei criteri sopra citati, qualora fossero soddisfatti, il procedimento per convalidare il documento è il seguente:

\begin{enumerate}
    \item \textbf{Accetta la Pull Request:} 
        accedere alla pagina della Pull Request in cui si agirà con il ruolo di revisore nel repository \href{https://github.com/ByteOps-swe/Sorgente-documenti}{Sorgente-documenti} su GitHub >> Risolvere eventuali conflitti >> Merge Pull Request;
    \item \textbf{Elimina il branch:} 
        eliminare il branch creato per la redazione del documento (o sezione);
    \item \textbf{Sposta la issue in Done:} 
        nella \href{https://github.com/orgs/ByteOps-swe/projects/1/views/1}{DashBoard documentazione} spostare la issue relativa al documento validato dalla sezione "Da revisionare" a "Done";
    \item \textbf{Controllo generazione PDF:} 
        un'automazione tramite GitHub Actions compilerà il file \LaTeX\ e genererà automaticamente il PDF nel branch main della repository \href{https://github.com/ByteOps-swe/Documents}{Documents} con la data di redazione nel caso il documento sia un verbale, oppure la versione aggiornata per tutte le altre tipologie di file. \\
        Se la procedura di compilazione dovesse fallire, il verificatore riceverà automaticamente una notifica via mail e dovrà accedere alla sezione "Actions" di GitHub per esaminare l'origine dell'errore e intraprendere le azioni necessarie per correggerlo.
\end{enumerate}

\subsubsection{Analisi}
Attività di controllo su oggetti statici (documentazione, codice) e dinamici (componenti software).

\paragraph{Analisi statica}
Questo genere di analisi prende il nome di "statica" proprio perché viene condotta sul prodotto senza la necessità di eseguirlo. \\ L'efficacia di questa pratica dipende in modo diretto dall'esperienza e dalla competenza dei verificatori coinvolti. Essa coinvolge l'utilizzo di metodi di lettura, sia manuali che automatici, volti a individuare eventuali errori formali come violazione di vincoli, presenza di difetti e manifestazione di proprietà indesiderate nel prodotto in questione. \\
Le due principali tecniche impiegate sono:

\paragraph{Walkthrough}
Il verificatore controlla nella totalità il prodotto in cerca di difetti o errori, senza svolgere una ricerca specifica per un certo tipo di errore. Questa metodologia implica appunto una verifica approfondita della documentazione e del codice attraverso un'analisi sistematica. Si promuove la collaborazione e l'interazione tra il verificatore e l'autore del prodotto, strutturata nei seguenti quattro passaggi:

\begin{enumerate}
    \item \textbf{Pianificazione:} 
        una fase di dialogo tra gli autori e i verificatori, finalizzata all'identificazione delle proprietà e dei vincoli che il prodotto deve soddisfare per essere considerato corretto;

    \item \textbf{Lettura:} 
        il verificatore esamina attentamente i documenti e/o il codice, individuando errori e verificando la conformità ai vincoli prestabiliti;

    \item \textbf{Discussione:} 
        successivo confronto tra autori e verificatori per discutere l'esito della lettura e valutare eventuali correzioni necessarie;

    \item \textbf{Correzione:} 
        attività assegnata agli autori per correggere gli errori individuati nei passaggi precedenti.
\end{enumerate}

Questo metodo di verifica sarà prevalentemente adottato nelle fasi iniziali del progetto, in quanto i prodotti soggetti a verifica saranno generalmente meno complessi e, di conseguenza, l'operazione risulterà più agevole e meno dispendiosa in termini di risorse.

Le attività in cui verrà applicata la tecnica del Walkthrough sono:
\begin{itemize}
    \item \textbf{Revisione dei requisiti:} 
        per assicurarsi che tutti i requisiti siano chiari, comprensibili e conformi alle esigenze del cliente;
    \item \textbf{Codifica del software:} 
        per identificare errori di logica, pratiche non ottimali o potenziali problemi di manutenibilità nel codice;
    \item \textbf{Documentazione tecnica:} 
        per assicurarsi che la documentazione tecnica sia accurata, chiara e completa.
\end{itemize}

\paragraph{Inspection}
L'obiettivo di questa tecnica consiste nel rilevare eventuali difetti nel prodotto in esame mediante un'analisi mirata, piuttosto che tramite una revisione completa che non tende ad individuare dei difetti specifici. \\
Tale approccio prevede la specifica preventiva degli elementi da verificare, i quali vengono organizzati in liste di controllo.
Queste liste fungono da \textit{checklist} per valutare l'accuratezza dell'attività d'ispezione, determinando se è stata condotta in modo corretto.
L'inspection risulta particolarmente vantaggiosa quando ci si trova di fronte a documenti o codice complessi e strutturati, specialmente nelle fasi avanzate del progetto. In questo contesto, il processo di verifica tramite inspection si rivela più efficace rispetto a un walkthrough, poiché quest'ultimo richiederebbe un considerevole impiego di risorse.

\paragraph{Analisi dinamica}
Nel processo di sviluppo software, è essenziale condurre una verifica accurata del codice prodotto al fine di garantirne il corretto funzionamento. Questo processo si avvale dell'analisi dinamica, una categoria di metodologie di analisi che richiedono l'esecuzione effettiva del prodotto.
L'analisi dinamica coinvolge l'esecuzione di una serie di casi di test durante l'attuazione del codice. L'obiettivo di tali test è assicurare l'esecuzione accurata del software e individuare eventuali discordanze tra i risultati ottenuti e quelli previsti. \\
È importante sottolineare che l'analisi dinamica non è applicabile alla documentazione.
Per assicurare l'efficacia dell'analisi dinamica, è necessario automatizzare e rendere ripetibile questo processo, garantendo così una valutazione oggettiva del prodotto. \\
Nel contesto dell'ingegneria del software, il test rappresenta la principale tecnica di analisi dinamica.

\subsubsection{Testing}
\label{subsubsec:Testing}
L'obiettivo del testing è assicurare il corretto funzionamento della componente soggetta al test, verificando che produca i risultati attesi e che rispetti accuratamente i vincoli assegnati. Questi test sono inoltre strumentali per individuare eventuali anomalie di funzionamento. \\
Per ciascun test, è essenziale definire i seguenti parametri:

\begin{itemize}
    \item \textbf{Ambiente:} 
        il sistema (hardware e software) utilizzato per eseguire il test;
    \item \textbf{Stato iniziale:} 
        i parametri del software al momento dell'esecuzione del test;
    \item \textbf{Input:} 
        i dati forniti in entrata per l'esecuzione del test;
    \item \textbf{Output:} 
        i risultati attesi in uscita in relazione a uno specifico input;
    \item \textbf{Commenti addizionali:} 
        eventuali osservazioni o annotazioni aggiuntive pertinenti al test.
\end{itemize}
Tali test andranno poi automatizzati.

\paragraph{Test di unità}
Questi test sono progettati per verificare singole unità di codice, come funzioni o metodi, in modo isolato e indipendente dal resto del sistema. L'obiettivo principale dei test di unità è garantire che ogni unità di codice funzioni correttamente, conformandosi alle specifiche e restituendo i risultati attesi.
Tali test si prestano quindi ad un alto grado di parallelismo, essi vengono pianificati durante la progettazione di dettaglio.
Devono essere eseguiti per primi, in quanto verificano l’integrità e la correttezza della singola unità, prima dell’integrazione con le altre.

Per implementare tali test, è consentito l'utilizzo di oggetti simulati o parziali, come mock e stub, al fine di separare l'unità di codice in esame dalle sue dipendenze esterne. Questo approccio permette di verificare il comportamento dell'unità in contesti controllati, garantendo un'efficace isolamento durante le fasi di test.

Un ulteriore obiettivo dei test di unità consiste nel verificare la massima copertura possibile dei percorsi all'interno dell'unità. A tal fine, vengono appositamente progettati per attivare specifici percorsi, creando così una serie di test dedicati che devono garantire una copertura completa del codice dell'unità, generando in tal modo la "structural coverage".

\paragraph{Test di integrazione}
I test di integrazione sono una fase essenziale nell'analisi dinamica del software e mirano a verificare il corretto funzionamento delle diverse unità di codice quando sono integrate per formare una componente più ampia o l'intero sistema.

Questa fase si concentra sull'interazione tra le parti del software per garantire che lavorino sinergicamente secondo le specifiche del progetto.

I test di integrazione vengono pianificati durante la fase di progettazione architetturale e possono avere un approccio:

\begin{itemize}
    \item \textbf{Top-down:}
        l'integrazione inizia con le componenti di sistema che presentano maggiori dipendenze e un maggiore valore esterno, consentendo la tempestiva disponibilità delle funzionalità di alto livello. Ciò consente di effettuare test prolungati sulle funzionalità principali, rendendole disponibili inizialmente ma richiede molti mock;
    \item \textbf{Bottom-up:}
        l'integrazione ha inizio dalle componenti di sistema caratterizzate da minori dipendenze e un maggiore valore interno, ossia quelle meno visibili all'utente. Questo implica la necessità di meno mock ma ritarda il test delle funzionalità utente esponendole per minor tempo a verifica.
\end{itemize}

Il team svolgerà, ove possibile, test di integrazione con l'approccio "Top down".

\paragraph{Test di sistema}
Questi test sono progettati per verificare l'intero sistema software rispetto ai requisiti specificati, garantendo che tutte le componenti siano integrate correttamente e che l'applicazione esegua le funzioni previste in modo accurato e affidabile.

In particolare devono essere implementati:
\begin{itemize}
    \item  \textbf{Test End-to-End:} 
        coinvolgono l'esecuzione completa del sistema, dalla sua interfaccia utente fino alle componenti di backend, al fine di simulare l'esperienza completa dell'utente.
\end{itemize}

I test di sistema vengono eseguiti dopo che sono stati completati con successo i test di integrazione.

\paragraph{Test di regressione}
Mirano a garantire che le modifiche apportate al codice non abbiano introdotto nuovi difetti o compromesso le funzionalità preesistenti del sistema.

Questi test sono essenziali per assicurare che le modifiche al software non causino regressioni, ovvero la ricomparsa di errori precedentemente risolti o la compromissione di funzionalità precedentemente funzionanti.

I test di regressione devono essere eseguiti ogni volta che vengono apportate modifiche al codice, garantendo una verifica continua e automatica della stabilità del sistema.

\paragraph{Test di accettazione}
I test di accettazione sono un passo fondamentale prima del rilascio del software e sono progettati per garantire che il prodotto finale sia in grado di soddisfare le aspettative degli utenti finali e che risponda in modo appropriato ai requisiti specificati.

\paragraph{Sequenza delle fasi di test}
La sequenza delle fasi di test è la seguente:

\begin{enumerate}
    \item Test di Unità;
    \item Test di Integrazione;
    \item Test di Regressione;
    \item Test di Sistema;
    \item Test di accettazione.
\end{enumerate}

\paragraph{Codici dei test}
Per classificare ogni test che il team effettuerà durante l'attività di verifica abbiamo deciso di associare un codice identificativo per ciascun test nel formato:

\begin{center}
    \textbf{T [tipo] [codice]}
\end{center}

dove:

\begin{itemize}
    \item \textbf{[tipo]:} 
        \begin{itemize}
            \item \textbf{U:} 
                test di unità;
            \item \textbf{I:} 
                test di integrazione;
            \item \textbf{S:} 
                test di sistema;
            \item \textbf{R:} 
                test di regressione;
            \item\textbf{A:} 
                test di accettazione.
        \end{itemize}
    \item \textbf{[codice]:} 
        è un numero associato al test all'interno del suo tipo:
        \begin{itemize}
            \item 
                se il test non ha un padre, è un semplice numero progressivo;
            \item 
                se il test ha un padre, sarà nel formato:
                \begin{center}
                    \textbf{[codice.padre] . [codice.figlio]}
                \end{center}
                con:
                \begin{itemize}
                    \item \textbf{[codice.padre] :} 
                        identifica in maniera univoca il padre del test all'interno della categoria di test relativi al suo tipo;
                    \item \textbf{[codice.figlio] :} 
                        numero progressivo per identificare il test.
                \end{itemize}
        \end{itemize}
\end{itemize}

\paragraph{Stato dei test}
Ad ogni test sarà assegnato uno stato che rifletterà il risultato della sua esecuzione. \\
I risultati dei test saranno registrati nel documento "\textit{Piano di Qualifica}", all'interno della sezione "\textit{Specifica dei test}". \\
Ogni test potrà assumere uno dei seguenti stati:

\begin{itemize}
    \item \textbf{NI:} 
        il test non è ancora stato implementato (Non implementato);
    \item \textbf{S:} 
        il test ha riportato esito positivo (Superato);
    \item \textbf{NS:}
        il test ha riportato esito negativo (Non Superato).
\end{itemize}

\hypertarget{subsubsec:strumentiVerifica}{\subsubsection{Strumenti}}
\begin{itemize}
    \item \textbf{Spell checker:} 
        controllo ortografico integrato nell’ambiente di lavoro;
    \item \textbf{Modulo "unittest" Python}.
\end{itemize}
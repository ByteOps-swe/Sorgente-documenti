\subsection{Sviluppo}

\subsubsection{Introduzione}
L'\href{https://www.math.unipd.it/~tullio/IS-1/2009/Approfondimenti/ISO_12207-1995.pdf}{ISO/IEC 12207:1995} stabilisce le linee guida per il processo di sviluppo, il quale include attività cruciali come analisi, progettazione, codifica, integrazione, testing, installazione e accettazione. È fondamentale svolgere queste attività in stretta aderenza alle linee guida e ai requisiti definiti nel contratto con il cliente, garantendo così un'implementazione accurata e conforme alle specifiche richieste.

\subsubsection{Analisi dei requisiti}
\paragraph{Descrizione}
L'analisi dei requisiti è un' attività critica nell'ambito dello sviluppo software poiché stabilisce le basi per il design, l'implementazione e i test del sistema. \\
Secondo lo standard \href{https://www.math.unipd.it/~tullio/IS-1/2009/Approfondimenti/ISO_12207-1995.pdf}{ISO/IEC 12207:1995}, lo scopo dell'analisi dei requisiti è di comprendere e definire in modo esaustivo le esigenze del cliente e del sistema. \\
L’attività di analisi richiede di rispondere a domande fondamentali come: “Qual è il dominio?”, “Qual è la cosa giusta da fare?”, "Quali sono le necessità del cliente?" e consiste nella comprensione approfondita del dominio e nella definizione chiara di obiettivi, vincoli e requisiti sia tecnici che funzionali.
\paragraph{Obiettivi:}
\begin{itemize}
    \item Definire insieme alla proponente gli obiettivi del prodotto per rispecchiarne le aspettative, comprendendo identificazione, documentazione e validazione dei requisiti funzionali e non funzionali;
    \item Facilitare la comprensione comune tra gli stakeholder;
    \item Permettere una stima sulle tempistiche e sui costi;
    \item Fornire ai progettisti requisiti chiari e di facile comprensione;
    \item Favorire l'attività di verifica e test fornendo dei riferimenti pratici.
\end{itemize}

\paragraph{Documentazione}
È compito degli analisti effettuare l'analisi dei requisiti, redigendo un documento con il medesimo nome che deve contenere:
\begin{itemize}
    \item \textbf{Introduzione}: Presentazione e scopo del documento stesso;
    \item \textbf{Descrizione}: Analisi del prodotto
          \begin{itemize}
              \item Obiettivi del prodotto;
              \item Funzionalità del prodotto;
              \item Caratteristiche utente;
              \item Tecnologie.
          \end{itemize}
    \item \textbf{Casi d'uso}: Funzionalità offerte dal sistema dal punto di vista dell'utente
        \begin{itemize}
            \item Attori: Utenti esterni al sistema;
            \item Elenco dei casi d'uso:
            \begin{itemize}
                \item Casi d'uso in formato testuale;
                \item Diagrammi dei casi d'uso.
            \end{itemize}  
            \item Eventuali diagrammi di attività: permettono di facilitare la comprensione dei processi relativi alle funzionalità.
        \end{itemize}
    \item \textbf{Requisiti}:
        \begin{itemize}
            \item Requisiti funzionali;
            \item Requisiti qualitativi;
            \item Requisiti di vincolo.
        \end{itemize}
\end{itemize}
\paragraph{Casi d'uso}
Forniscono una descrizione dettagliata delle funzionalità del sistema dal punto di vista degli utenti, identificando come il sistema risponde a determinate azioni o scenari. In breve, i casi d'uso sono strumenti utilizzati nell'analisi dei requisiti per catturare e illustrare in modo chiaro e comprensibile come gli utenti interagiranno con il software e quali saranno i risultati di tali interazioni. \\
Ogni caso d'uso testuale deve essere costituito da:
\begin{enumerate}
    \item \textbf{Identificativo} nel formato:\\
          \begin{center}
              \textbf{UC [Numero caso d'uso] . [Numero sotto caso d'uso] - [Titolo]}
          \end{center}
          (ex. UC6.1 - Visualizzazione posizione sensore).\\
          con:
          \begin{itemize}
              \item \textbf{Numero caso d'uso:} ID numerico del caso d'uso;
              \item \textbf{Numero sotto caso d'uso:} ID numerico del sottocaso d'uso (presente esclusivamente se si sta identificando un sottocaso d'uso).
              \item \textbf{Titolo}: Titolo breve ed esplicativo del caso d'uso.
          \end{itemize}
    \item \textbf{Attore principale:} Entità esterna che interagisce attivamente con il sistema per soddisfare una sua necessità;
    \item \textbf{Attore secondario:} Eventuale entità esterna che non interagisce attivamente con il sistema, ma all'interno di un caso d'uso permette al sistema di soddisfare il bisogno dell'attore principale;
    \item \textbf{Descrizione:} Eventuale descrizione breve della funzionalità;
    \item \textbf{Scenario principale:} Sequenza di eventi che si verificano quando un attore interagisce con il sistema per raggiungere l'obbiettivo del caso d'uso (postcondizioni);
    \item \textbf{Estensioni:} Eventuali scenari alternativi che, in seguito ad una o più specifiche condizioni, portano il flusso del caso d'uso a non giungere alle postcondizioni;
    \item \textbf{Precondizioni:} Stato in cui si deve trovare il sistema affinché la funzionalità sia disponibile all'attore;
    \item \textbf{Postcondizioni:} Stato in cui si trova il sistema dopo l'esecuzione dello scenario principale;
    \item \textbf{User story associata:} Breve descrizione di una funzionalità del software, scritta dal punto di vista dell'utente, che fornisce contesto, obiettivi e valore. \\
    Nella forma: "Come [utente] desidero poter [funzionalita] per [valore aggiunto]".
\end{enumerate}

\paragraph{Diagrammi dei casi d'uso} 
I diagrammi dei casi d'uso sono strumenti grafici che permettono di visualizzare in modo chiaro e intuitivo le funzionalità offerte dal sistema dal punto di vista dell'utente. Inoltre, consentono di identificare e comprendere rapidamente le relazioni e le interazioni tra i vari casi d'uso, offrendo una visione d'insieme delle funzionalità offerte dal sistema.\\
I diagrammi dei casi d'uso si concentrano sulla descrizione delle funzionalità del sistema dal punto di vista degli utenti senza approfondire dettagli implementativi. La loro finalità principale è quella di evidenziare le interazioni dall'esterno al sistema, offrendo una visione focalizzata sulle funzionalità e sull'interazione dell'utente con il sistema stesso. \\
Un diagramma dei casi d'uso fornisce una panoramica visuale delle interazioni chiave tra gli attori e il sistema, facilitando la comprensione dei requisiti funzionali del sistema e la comunicazione tra gli stakeholder del progetto. \\
Di seguito sono elencati i principali componenti di un diagramma dei casi d'uso:

\begin{itemize}
    \item \textbf{Attori:}
    Gli attori sono le entità esterne al sistema che interagiscono con esso e possono essere utenti umani, altri sistemi software o componenti esterne. \\
    Gli attori sono rappresentati come "stickman" all'esterno del rettangolo che delinea il sistema.
    \begin{minipage}[t]{\linewidth}
        \centering
        \includegraphics[width=0.6\textwidth]{../Images/NormeDiProgetto/Attore.PNG}
        \captionof{figure}{Rappresentazione Attore}
    \end{minipage}

    \item \textbf{Casi d'Uso:}
    I casi d'uso identificano le diverse funzionalità offerte dal sistema con cui l'attore può interagire. \\
    Ogni caso d'uso viene rappresentato tramite una forma ovale contenente un ID ed un titolo esplicativo.
    \begin{minipage}[t]{\linewidth}
        \centering
        \includegraphics[width=0.6\textwidth]{../Images/NormeDiProgetto/UC.PNG}
        \captionof{figure}{Rappresentazione caso d'uso}
    \end{minipage}

    \item \textbf{Sottocasi d'uso:}
    Un sottocaso d'uso rappresenta una versione più dettagliata di un caso d'uso più generico, offrendo un livello di dettaglio più approfondito sulle funzionalità o sui particolari scenari di utilizzo rispetto al caso d'uso principale.
    \begin{minipage}[t]{\linewidth}
        \centering
        \includegraphics[width=0.6\textwidth]{../Images/NormeDiProgetto/SottocasoD'Uso.PNG}
        \captionof{figure}{Rappresentazione sottocaso d'uso}
    \end{minipage}

    \item \textbf{Sistema:}
    Il sistema viene rappresentato da un rettangolo e viene identificato con un titolo. All'interno del sistema saranno collocati i casi d'uso, mentre al suo esterno gli attori.
    \begin{minipage}[t]{\linewidth}
        \centering
        \includegraphics[width=0.6\textwidth]{../Images/NormeDiProgetto/Sistema.PNG}
        \captionof{figure}{Rappresentazione sistema}
    \end{minipage}

    \item \textbf{Relazioni tra Attori e Casi d'Uso:}
    \begin{itemize}
        \item \textbf{Associazione:} \\
        Le linee di associazione collegano gli attori ai casi d'uso corrispondenti, indicando quali attori sono coinvolti in una particolare interazione. Più precisamente, una linea di associazione collega un attore a un caso d'uso quando quell'attore è coinvolto nell'interazione descritta dal caso d'uso stesso. Questo legame rappresenta visivamente il ruolo dell'attore nell'utilizzo o nell'avvio di una funzione specifica offerta dal sistema.
        \begin{minipage}[t]{\linewidth}
            \centering
            \includegraphics[width=0.6\textwidth]{../Images/NormeDiProgetto/Associazione.PNG}
            \captionof{figure}{Rappresentazione associazione}
        \end{minipage}
    \end{itemize}

    \item \textbf{Relazioni tra attori:}
    \begin{itemize}
        \item \textbf{Generalizzazione tra attori:} \\
        La generalizzazione tra attori rappresenta una relazione di ereditarietà, dove un attore specializzato (figlio) eredita comportamenti e caratteristiche da un attore base (genitore). \\
        Questo aiuta a organizzare gerarchicamente gli attori coinvolti nell'interazione con il sistema nei diagrammi dei casi d'uso. \\
        Viene rappresentata con una linea solida e una freccia vuota che parte dall'attore figlio e arriva all'attore padre.
        \begin{minipage}[t]{\linewidth}
            \centering
            \includegraphics[width=0.6\textwidth]{../Images/NormeDiProgetto/GeneralizzazioneAttori.PNG}
            \captionof{figure}{Rappresentazione generalizzazione tra attori}
        \end{minipage}
    \end{itemize}
    
    \item \textbf{Relazioni tra casi d'uso:}
    \begin{itemize}
        \item \textbf{Inclusione:} \\
        La relazione di inclusione indica che un caso d'uso (detto "includente") include l'esecuzione di un altro caso d'uso (detto "incluso"). \\
        In pratica, quando un attore interagisce con il caso d'uso includente, il caso d'uso incluso viene eseguito come parte integrante del primo. Questo è utile per favorire il riutilizzo e per evitare duplicazione in diversi casi d'uso. \\
        La relazione di inclusione viene rappresentata da una freccia tratteggiata che collega il caso d'uso incluso al caso d'uso che lo include. \\
        Esempio: Supponiamo che per un applicazione e-commerce ci sia un caso d'uso "Conferma ordine". Questo caso d'uso può includere il caso d'uso "Visualizza carrello". Dopo la conferma dell'ordine, l'utente viene automaticamente reindirizzato alla visualizzazione del carrello al fine di ottenere una panoramica completa dei contenuti dell'ordine.
        \begin{minipage}[t]{\linewidth}
            \centering
            \includegraphics[width=0.6\textwidth]{../Images/NormeDiProgetto/Inclusione.PNG}
            \captionof{figure}{Rappresentazione inclusione}
        \end{minipage}

        \item \textbf{Estensione:} \\
        La relazione di estensione indica che un caso d'uso (detto "estendente") può estendere il comportamento di un altro caso d'uso (detto "esteso") in determinate circostanze. In altre parole, l'esecuzione del caso d'uso estendente può essere estesa o arricchita dal caso d'uso esteso al verificarsi di determinate condizioni. \\
        La relazione di estensione è rappresentata da una freccia tratteggiata che collega il caso d'uso estendente al caso d'uso esteso. \\
        Esempio: Considera un caso d'uso "Visualizzazione errore di autenticazione". Questo caso d'uso potrebbe estendere il caso d'uso "Autenticazione" se durante la fase di autenticazione si inseriscono username e/o password non validi. In questo modo, l'estensione permette di gestire situazioni alternative senza ingombrare lo scenario principale di un caso d'uso e permettendo di evitare duplicazione.
        \begin{minipage}[t]{\linewidth}
            \centering
            \includegraphics[width=0.6\textwidth]{../Images/NormeDiProgetto/Estensione.PNG}
            \captionof{figure}{Rappresentazione estensione}
        \end{minipage}

        \item \textbf{Generalizzazione casi d'uso:} \\
        La generalizzazione nei diagrammi dei casi d'uso rappresenta una relazione di ereditarietà tra casi d'uso, indicando che un caso d'uso più specifico eredita il comportamento da un caso d'uso più generico. \\
        Questa relazione è simboleggiata da una linea con una freccia vuota che punta dal caso d'uso più specifico al caso d'uso più generico.
        \begin{minipage}[t]{\linewidth}
            \centering
            \includegraphics[width=0.6\textwidth]{../Images/NormeDiProgetto/GeneralizzazioneUC.PNG}
            \captionof{figure}{Rappresentazione generalizzazione}
        \end{minipage}
    \end{itemize}

\end{itemize}

\paragraph{Requisiti}
I requisiti di un prodotto software sono specifiche dettagliate e documentate che delineano le funzionalità, le prestazioni, i vincoli e altri aspetti critici che il software deve soddisfare. Questi requisiti fungono da guida per lo sviluppo, il testing e la valutazione del prodotto, assicurando che risponda alle esigenze degli utenti e agli obiettivi del progetto.
Includono
\begin{itemize}
    \item \textbf{Requisiti funzionali:} Descrivono le funzionalità che il software deve avere.
    \item \textbf{Requisiti non funzionali:} Definiscono principalmente criteri di prestazione, qualità, sicurezza e vincoli del sistema, ovvero caratteristiche che non riguardano direttamente le funzionalità specifiche del software.
\end{itemize}
Una precisa definizione dei requisiti è fondamentale: devono risultare inequivocabili e rispondere pienamente alle attese del cliente o del proponente.\\
Ogni requisito è costituito da:
\begin{enumerate}
    \item \textbf{Identificativo} nel formato:\\
          \begin{center}
              \textbf{R [Abbreviazione tipologia requisito] [Codice]}
          \end{center}
          con:
          \begin{itemize}
              \item \textbf{Abbreviazione tipologia requisito:}
                    \begin{itemize}
                        \item \textbf{RF:} Requisito funzionale;
                        \item \textbf{RQ:} Requisito qualitativo;
                        \item \textbf{RV:} Requisito di vincolo;
                    \end{itemize}
              \item \textbf{Codice:} Identificativo progressivo all'interno della tipologia di requisito.
          \end{itemize}
    \item \textbf{Importanza:}
          \begin{itemize}
              \item \textbf{Obbligatorio:} Irrinunciabile per qualcuno degli stakeholder;
              \item \textbf{Desiderabile:} Non strettamente necessario ma a valore aggiunto;
              \item \textbf{Opzionale:} Relativamente utile o contrattabile più avanti nel tempo.
          \end{itemize}
    \item \textbf{Descrizione:} Narrazione chiara e dettagliata che fornisce una spiegazione completa del comportamento o della caratteristica che il software deve possedere;
    \item \textbf{Fonte:} Fonte del requisito (ex. Capitolato, Verbale interno/esterno);
    \item \textbf{Casi d'uso:} Elenco casi d'uso associati.
\end{enumerate}
\paragraph{Metriche}
Le metriche nell'analisi dei requisiti sono strumenti utilizzati per valutare, misurare e gestire diversi aspetti dei requisiti di un sistema o di un progetto. Queste metriche aiutano a garantire che i requisiti siano completi, corretti, coerenti e comprensibili.
\begin{table}[h]
    \centering
    \begin{tabular}{|c|c|c|}
    \hline
    Metrica & Nome & Riferimento \\
    \hline \hline
    MROS & Requisiti obbligatori soddisfatti &  \\
    MRDS & Requisiti desiderabili soddisfatti &  \\
    MROPZS & Requisiti opzionali soddisfatti & \\
    \hline
    \end{tabular}
    \caption{Metriche relative all'attività di analisi dei requisiti}
\end{table}

Altri aspetti da valutare per ottenere una specifica dei requisiti ottimale sono: \todo{non so se ha senso tenere questa parte, forse bastano le metriche}
\begin{itemize}
    \item \textbf{Completezza dei requisiti:} Misura la quantità di requisiti identificati rispetto a quelli effettivamente necessari per il sistema. Una metrica comune è la percentuale di requisiti identificati rispetto a quelli totali;
    \item \textbf{Coerenza:} Valuta la coerenza tra i requisiti. Ad esempio, misurare il numero di conflitti o di requisiti duplicati;
    \item \textbf{Tracciabilità:} Indica la capacità di tracciare i requisiti attraverso le fasi del progetto. Si possono usare metriche come il numero di requisiti tracciati rispetto al totale;
    \item \textbf{Comprensibilità:} Misura la chiarezza e la comprensibilità dei requisiti. Si potrebbe valutare tramite sondaggi o questionari la facilità con cui gli stakeholder comprendono i requisiti;
    \item \textbf{Stabilità:} Misura quanto i requisiti cambiano nel tempo. Si possono usare metriche come il tasso di cambiamento dei requisiti per periodo;
    \item \textbf{Priorità:} Valuta l'importanza relativa dei requisiti. Si possono assegnare punteggi di priorità ai requisiti e valutare la distribuzione di questi punteggi;
    \item \textbf{Testabilità:} Misura la facilità con cui i requisiti possono essere verificati tramite test. Si potrebbe valutare la quantità di requisiti che possono essere testati e quelli che richiedono ulteriori specifiche per la verifica;
    \item \textbf{Misurazione del rischio:} Valuta il livello di rischio associato ai requisiti. Si potrebbero utilizzare valutazioni qualitative o quantitative per attribuire livelli di rischio a ciascun requisito.
\end{itemize}
Ognuna di queste metriche è necessaria ad assicurare che i requisiti siano gestiti in modo efficace e che siano allineati alle esigenze degli stakeholder.

\paragraph{Strumenti}
\begin{itemize}
    \item \href{https://staruml.io/}{\textbf{StarUML:}} applicazione software utilizzata per la realizzazione di diagrammi e modelli UML.
\end{itemize}

\subsubsection{Progettazione}

\paragraph{Descrizione}
Lo scopo primario dell'attività di progettazione consiste nell'identificare una soluzione realizzativa ottimale che soddisfi appieno le esigenze di tutti gli stakeholder, considerando i requisiti e le risorse disponibili. \\
La progettazione risponde alla domanda chiave: 'Qual è il modo migliore per realizzare ciò di cui c'è bisogno?'. \\
È cruciale definire l'architettura del prodotto prima di avviare la fase di codifica, perseguendo correttezza per costruzione piuttosto che correttezza per correzione. Questo approccio permette di gestire in modo efficiente la complessità del prodotto, garantendo una struttura robusta e coesa durante l'intero processo di sviluppo. \\

\paragraph{Obiettivi}
L'obiettivo principale è quindi quello di assicurare il soddisfacimento dei requisiti attraverso un sistema di qualità delineato dall'architettura del prodotto. Questo comporta:
\begin{itemize}
    \item Identificare parti componibili conformi ai requisiti, dotate di specifiche chiare e coese, sviluppandole con risorse sostenibili e costi contenuti;
    \item Organizzare il sistema in modo da agevolare adattamenti futuri;
    \item Gestire la complessità del sistema attraverso una progettazione dettagliata, suddividendo il sistema in unità architetturali per semplificare la codifica di ciascuna parte, rendendola facilmente gestibile, veloce e verificabile.
\end{itemize}
Inizialmente, il team di progettazione condurrà un'analisi approfondita per selezionare con attenzione le tecnologie più adatte, valutandone attentamente i punti di forza, le debolezze ed eventuali criticità. \\
Una volta individuate le tecnologie appropriate, si procede allo sviluppo di un'architettura di alto livello per comprendere e delineare la struttura generale del prodotto, costituendo così una base di partenza per la realizzazione del PoC.
Questa architettura fornisce una visione panoramica del sistema, identificando i principali componenti, i flussi di dati e le interazioni tra di essi. Si presterà particolare attenzione a rendere il sistema flessibile e adatto a potenziali modifiche future. \\
Successivamente, si avvierà lo sviluppo di un Proof of Concept (PoC), parte fondamentale della Technology Baseline, per valutare le decisioni prese riguardo all'architettura e alle tecnologie adottate, nonché per verificarne l'aderenza agli obiettivi e alle specifiche del progetto. \\
In seguito allo sviluppo e ad un'attenta analisi del POC, si procederà con iterazioni aggiuntive, apportando miglioramenti, aggiustamenti e aggiunte, fino a giungere a un design completo. Questo design sarà fondamentale per lo sviluppo dell'MVP (Minimum Viable Product), che costituirà una versione essenziale e funzionale del prodotto e che sarà parte della Product Baseline.

\paragraph{Documentazione}
\textbf{Specifica tecnica} \\
Il documento descrive in modo approfondito il design definitivo del prodotto e fornisce istruzioni precise agli sviluppatori, guidandoli nella corretta implementazione della soluzione software secondo i requisiti e le specifiche indicate. Ciò permette di ridurre la complessità e le ambiguità nel processo di sviluppo del software, contribuendo a garantire che il prodotto finale sia allineato alle aspettative del cliente e funzioni in modo ottimale.
Questo documento comprende diversi elementi cruciali: 
\begin{itemize}
    \item \textbf{Tecnologie utilizzate}: Specifica le tecnologie e le librerie di terze parti integrate nel sistema;
    \item \textbf{Architettura logica}: Definisce i componenti, i ruoli, le connessioni e le interazioni nel sistema;
    \item \textbf{Architettura di deployment}: Indica come le componenti architetturali vengono allocate e distribuite nel sistema in esecuzione;
    \item \textbf{Pattern architetturali e design pattern}: Descrive i design pattern architetturali adottati e quelli influenzati dalle tecnologie utilizzate;
    \item \textbf{Vincoli e linee guida}: Include restrizioni e regole da seguire durante lo sviluppo;
    \item \textbf{Procedure di testing e validazione}: Indica i processi per testare e verificare che il software soddisfi i requisiti specificati;
    \item \textbf{Requisiti tecnici}: Specifica in dettaglio i requisiti prestazionali, di sicurezza, di scalabilità e di compatibilità con determinate piattaforme che il software deve soddisfare
\end{itemize}

\paragraph{Qualità dell'architettura}
\begin{itemize}
    \item \textbf{Sufficienza}: L'architettura soddisfa i requisiti funzionali e non funzionali definiti per il software, senza sovradimensionamento o sottodimensionamento;
    \item \textbf{Comprensibilità}: La chiarezza e la facilità con cui è possibile comprendere l'architettura software, rendendo agevole per gli sviluppatori e gli stakeholder capire come funziona il sistema;
    \item \textbf{Modularità}: L'architettura è suddivisa in moduli o componenti chiaramente definiti, consentendo la separazione delle responsabilità e facilitando la manutenzione, l'aggiornamento e lo sviluppo parallelo;
    \item \textbf{Robustezza}: La capacità del software di gestire situazioni anomale o errate senza interruzioni gravi o perdite di dati, mantenendo un funzionamento accettabile;
    \item \textbf{Flessibilità}: La facilità con cui il sistema può essere adattato o esteso per soddisfare nuovi requisiti o cambiamenti senza richiedere modifiche radicali o strutturali;
    \item \textbf{Riusabilità}: La capacità di riutilizzare parti del software in contesti diversi, riducendo lo sforzo di sviluppo e migliorando l'efficienza;
    \item \textbf{Efficienza}: Il software utilizza in modo ottimale le risorse disponibili, come memoria e CPU, per eseguire le sue funzioni nel minor tempo possibile;
    \item \textbf{Affidabilità}: La capacità del software di svolgere correttamente le sue funzioni in modo coerente e prevedibile nel tempo;
    \item \textbf{Disponibilità}: Il software è accessibile e operativo quando richiesto, riducendo al minimo i tempi di inattività non pianificati;
    \item \textbf{Sicurezza rispetto a malfunzionamenti (Safety)}: La prevenzione di danni fisici o danni a persone o beni a causa di malfunzionamenti del software;
    \item \textbf{Sicurezza rispetto a intrusioni (Security)}: La protezione del software da accessi non autorizzati, manipolazioni e intrusioni esterne;
    \item \textbf{Semplicità}: La capacità di mantenere l'architettura software il più semplice possibile senza compromettere la funzionalità o l'efficacia;
    \item \textbf{Incapsulazione}: Il nascondere dei dettagli implementativi all'esterno di un componente, consentendo l'accesso solo attraverso un'interfaccia definita;
    \item \textbf{Coesione}: La misura in cui i componenti all'interno di un modulo o un'unità funzionano insieme per un obiettivo comune senza essere eccessivamente interdipendenti;
    \item \textbf{Basso accoppiamento}: Il grado di dipendenza tra i diversi moduli o componenti del software, cercando di minimizzare le interazioni o le dipendenze tra di essi per migliorare la manutenibilità e la flessibilità del sistema.
\end{itemize}

\paragraph{Diagrammi UML}
Vantaggi:
\begin{itemize}
    \item \textbf{Chiarezza nella comunicazione}: Rendono più comprensibili e chiari i concetti tecnici ai team e agli stakeholder;
    \item \textbf{Standardizzazione}: Offrono un linguaggio comune per la documentazione e la comprensione dei sistemi software;
    \item \textbf{Analisi e progettazione visiva}: Aiutano a identificare errori e lacune nel progetto prima dell'implementazione;
    \item \textbf{Modellazione e simulazione}: Consentono la creazione di modelli predittivi, riducendo rischi e costi durante lo sviluppo;
    \item F\textbf{acilitano la manutenzione}: Semplificano la comprensione della struttura del software, agevolando le operazioni di manutenzione;
    \item \textbf{Riducono errori di progettazione}: Aiutano a individuare problemi prima dell'implementazione, riducendo correzioni costose;
    \item \textbf{Supportano la documentazione}: Offrono una guida visiva per comprendere il sistema, inclusa nella documentazione del progetto.
\end{itemize}

A supporto dell'attività di progettazione verranno utlizzati i \textbf{Diagrammi delle classi}. \\

\paragraph*{Diagrammi delle classi}
Ciascun diagramma delle classi rappresenta le proprietà e le relazioni tra le varie componenti di un sistema, offrendo una prospettiva statica e non a run time. \\
Le classi sono rappresentate graficamente sotto forma di rettangoli divisi in tre sezioni:
\begin{enumerate}
    \item \textbf{Nome della classe}: Identificativo della classe. \\
    È rappresentato in grassetto seguendo la convenzione PascalCase e deve esplicitare chiaramente la responsabilità della classe. Se la classe è astratta, il nome viene scritto in corsivo.
    \item \textbf{Attributi}: Ogni elemento sarà presentato in una riga separata, secondo il seguente formato: \\
    \begin{center}\texttt{Visibilità Nome: Tipo [Molteplicità] = Valore/i di Default}\end{center}
    \begin{itemize}
        \item \textbf{Visibilità}: precede obbligatoriamente ogni attributo e rappresenta uno dei seguenti indicatori:
        \begin{itemize}
            \item $-$ : Visibilità privata;
            \item $+$ : Visibilità pubblica;
            \item $\#$ : Visibilità protetta;
            \item $\sim$ : Visibilità di package;
        \end{itemize}
        \item \textbf{Nome}: Rappresenta univocamente l'attributo. Dev'essere rappresentativo dell'attributo e deve seguire la notazione \texttt{nomeAttributo: tipo}. \\
        Qualora l'attributo fosse di tipo costante, allora il nome verrà scritto interamente in maiuscolo \texttt{NOMEATTRIBUTO: tipo};
        \item \textbf{Molteplicità}: Nel caso di una sequenza di elementi, come liste o array, la sua lunghezza può essere specificata con la sintassi \texttt{tipoAttributo[molteplicità]}. \\
        Se la sequenza contiene un numero di elementi non conosciuto a priori, verrà adottata la sintassi \texttt{tipoAttributo[*]}. \\
        Nel caso di un singolo elemento, la sua dichiarazione è opzionale.
        \item \textbf{Default}: Ogni attributo può essere dichiarato con un valore di default.
    \end{itemize}
    \item \textbf{Firme dei metodi}: Descrivono il comportamento delle classi individuate. Ogni metodo occuperà una riga e seguiranno il formato: \\
    \begin{center} \texttt{Visibilità Nome (Parametri Formali): Tipo di Ritorno} \end{center}
    \begin{itemize}
        \item \textbf{Visibilità}: Segue la convenzione definita per gli attributi.
        \item \textbf{Nome}: Rappresenta l'identificativo univoco del metodo e descrive in modo esplicito il suo obiettivo, seguendo la notazione \textit{PascalCase}.
        \item \textbf{Parametri formali}: Il loro numero varia da $0$ a $n$ e sono separati tramite la virgola. Ogni parametro seguirà la notazione e le convenzioni definite per gli attributi.
        \item \textbf{Tipo di ritorno}: Determina il tipo che verrà ritornato dal metodo.
    \end{itemize}
\end{enumerate}

\vspace{15pt}

I metodi getter, setter e i costruttori non vengono inclusi fra i metodi;  \\
I metodi astratti sono scritti in corsivo; \\
I metodi statici sono sottolineati; \\
L'assenza di attributi o metodi in una classe, determina una visualizzazione di campi vuoti nel diagramma delle classi. \\ 

\vspace{15pt}

I diagrammi delle classi sono collegati tra loro mediante frecce che delineano le rispettive relazioni di dipendenza. \\
Qui di seguito, saranno delineate le rappresentazioni mediante frecce per le diverse relazioni: \\
\begin{itemize}
    \item \textbf{Dipendenza}: Se la classe A utilizza servizi, metodi o membri forniti dalla classe B, si dice che la classe A dipende dalla classe B e tale relazione viene rappresentata con una freccia tratteggiata dalla classe A alla classe B. \\
    La relazione di dipendenza indica il minor grado di accoppiamento tra due classi: un cambiamento nella classe B può influenzare la classe A, ma non viceversa.
    \begin{figure}[H]
        \centering
        \includegraphics[width=0.6\textwidth]{../Images/NormeDiProgetto/ClassDiagram_Dipendenza.PNG}
        \caption{Diagramma delle classi di una relazione di Dipendenza.}
    \end{figure}
    \item \textbf{Associazione}: L'associazione tra due classi viene rappresentata tramite una linea continua e orientata. Questa connessione indica che la classe A contiene campi o istanze della classe B. \\
    Le molteplicità di occorrenza possono essere espresse tramite valori posizionati agli estremi della freccia:
    \begin{itemize}
        \item $\mathbf{0...1}$: A può possedere 0 o 1 istanza di B;
        \item $\mathbf{0...*}$: A può possedere 0 o più istanze di B;
        \item $\mathbf{1}$:  A possiede esattamente un'istanza di B (in questo caso non è necessario specificare la molteplicità);
        \item $\mathbf{*}$: A possiede più istanze di B;
        \item $\mathbf{n}$: A possiede esattamente n istanze di B.
    \end{itemize}
    \begin{figure}[H]
        \centering
        \includegraphics[width=0.6\textwidth]{../Images/NormeDiProgetto/ClassDiagram_Associazione.PNG}
        \caption{Diagramma delle classi di una relazione di Associazione.}
    \end{figure}
    \item \textbf{Aggregazione}: Rappresentata con una freccia a diamante vuota. \\
    Indica una relazione "parte di" (part of) in cui una classe è composta da diverse parti (altre classi), ma le parti possono esistere anche indipendentemente dalla classe principale. Nella figura la classe B è parte della classa A.
    \begin{figure}[H]
        \centering
        \includegraphics[width=0.6\textwidth]{../Images/NormeDiProgetto/ClassDiagram_Aggregazione.PNG}
        \caption{Diagramma delle classi di una relazione di Aggregazione.}
    \end{figure}
    \item \textbf{Composizione}: Rappresentata con una freccia a diamante piena. È simile all'aggregazione, ma le parti (altre classi) sono strettamente dipendenti dalla classe principale e non possono esistere indipendentemente. \\
    Nella figura la classe B è parte della classe A ed esiste solo come parte di A.
    \begin{figure}[H]
        \centering
        \includegraphics[width=0.6\textwidth]{../Images/NormeDiProgetto/ClassDiagram_Composizione.PNG}
        \caption{Diagramma delle classi di una relazione di Composizione.}
    \end{figure}
    \item \textbf{Generalizzazione}: Rappresentata con una freccia continua vuota. Rappresenta la relazione "is a" (è un) tra una classe genitore (superclasse) e una classe figlia (sottoclasse). La classe figlia eredita attributi e comportamenti dalla classe genitore. \\
    Equivale all'ereditarietà nei linguaggi di programmazione. \\
    Le proprietà della superclasse non si riportano nel diagramma della sottoclasse, a meno di override.
    \begin{figure}[H]
        \centering
        \includegraphics[width=0.6\textwidth]{../Images/NormeDiProgetto/ClassDiagram_Generalizzazione.PNG}
        \caption{Diagramma delle classi di una relazione di Generalizzazione.}
    \end{figure}
    \item \textbf{Interface Realization}: La relazione di "interface realization" indica che una classe fornisce l'implementazione dei metodi definiti in un'interfaccia specifica. Questa relazione è importante quando si desidera mostrare come una classe concreta soddisfi i requisiti di un'interfaccia specifica definendo e implementando i suoi metodi. \\
    Nella figura l'interfaccia A, rappresentata tramite un cerchio, viene implementata dalla classe B e questa relazione viene rappresentata graficamente con una linea da B ad A.
    \begin{figure}[H]
        \centering
        \includegraphics[width=0.6\textwidth]{../Images/NormeDiProgetto/InterfaceRealization.PNG}
        \caption{Diagramma delle classi di una relazione di Interface Realization.}
    \end{figure}
\end{itemize}

\paragraph{Design Pattern}
I design pattern costituiscono una risposta consolidata a problemi di progettazione che si presentano ciclicamente in determinati contesti. Questi modelli offrono un approccio di progettazione riusabile, garantendo qualità nella soluzione ed una rapida implementazione.
L'adozione di un design pattern avviene soprattutto quando una soluzione si è dimostrata efficace in un contesto specifico. Solitamente vengono fornite guide dettagliate sull'applicazione dei pattern, delineando il loro utilizzo ottimale.
Ogni design pattern deve essere accompagnato da una rappresentazione grafica illustrativa del suo funzionamento, da una spiegazione testuale della sua logica e da una descrizione della sua utilità all'interno dell'architettura complessiva. Questa documentazione svolge un ruolo chiave nel favorire una comprensione approfondita dell'integrazione del design pattern nell'architettura generale e nella prevenzione di errori di progettazione.

\paragraph{Test}
Nell'ambito del processo di sviluppo, il testing riveste un ruolo fondamentale nell'assicurare la qualità del prodotto finale. Durante questa fase, si delineano i requisiti di testing, si definiscono i casi di test e i criteri di accettazione, fungendo da strumenti per valutare il software. \\
Il suo obiettivo principale è individuare e risolvere eventuali problemi o errori presenti nel software prima del rilascio del prodotto finale. In aggiunta, il processo di testing è essenziale per garantire che il software soddisfi le specifiche e le aspettative del cliente. \\
I progettisti avranno il completo controllo di questa attività, compresa la definizione dei test da eseguire. Inoltre, nella sezione \ref{subsec:Testing}, si può trovare una descrizione dettagliata delle varie tipologie di test e della terminologia da adottare, offrendo così un'ulteriore chiarezza su questa fase critica del processo di sviluppo del software.

\paragraph{Metriche}
\begin{table}[H]
    \centering
    \begin{tabular}{|c|c|c|}
    \hline
    Metrica & Nome & Riferimento \\
    \hline \hline
    MAC & Accoppiamento tra classi &  \\
    MATC & Attributi per classe &  \\
    MPM & Parametri per metodo & \\
    MLCM & Linee di codice per metodo &  \\ 
    \hline
    \end{tabular}
    \caption{Metriche relative all'attività di progettazione}
\end{table}

\paragraph{Strumenti}
\begin{itemize}
    \item \href{https://staruml.io/}{\textbf{StarUML:}} applicazione software utilizzata per la realizzazione di diagrammi e modelli UML.
\end{itemize}

\subsubsection{Codifica}
\paragraph{Descrizione}
L'attività di codifica è affidata al ruolo del programmatore e rappresenta il momento cruciale in cui le funzionalità richieste dal proponente prendono forma. \\
Durante questa fase, le idee e i concetti delineati dai progettisti vengono tradotti in codice, creando istruzioni e procedure che i calcolatori possono eseguire. \\
I programmatori devono rispettare scrupolosamente le linee guida e le norme stabilite per garantire che il codice sia in linea con le specifiche stabilite e che traduca in modo accurato le concezioni iniziali dei progettisti.
\paragraph{Obiettivi}
La codifica è finalizzata alla creazione di un prodotto software in linea con le richieste del committente e conforme agli accordi stipulati.\\
Il rigoroso rispetto delle norme garantisce la creazione di codice di alta qualità, facilitando la manutenzione, l'estensione e la verifica del software, contribuendo costantemente al miglioramento della sua qualità complessiva.
\paragraph{Norme di codifica}
Le seguenti norme sono state formalizzate prendendo spunto dal libro "Clean Code" di Robert C. Martin.

\begin{itemize}
    \item \textbf{Nomi significativi}: usare nomi che riflettano il significato e lo scopo delle variabili, funzioni e classi. Evitare abbreviazioni ambigue.
    \item \textbf{Indentazioni e formattazione consistente}: l'utilizzo di un tab per ciascun livello di annidamento è fondamentale per assicurare una struttura coerente del codice, migliorandone la comprensione e agevolandone la gestione.
    \item \textbf{Lunghezza dei metodi}: la lunghezza ottimale dei metodi può variare a seconda del contesto e delle best practices di programmazione. Tuttavia, in generale, molti esperti consigliano che i metodi siano brevi e focalizzati su una singola responsabilità. Un principio comune è quello espresso da Robert C. Martin nel suo libro "Clean Code", che suggerisce che i metodi dovrebbero essere idealmente lunghi quanto basta per svolgere una singola operazione e non più lungo di quanto si possa visualizzare senza dover scorrere la pagina. \\
    Questo favorisce:
    \begin{itemize}
        \item \textbf{Chiarezza};
        \item \textbf{Manutenibilità};
        \item \textbf{Comprensibilità};
        \item \textbf{Testabilità:} Metodi più brevi sono più facili da testare in isolamento, il che favorisce l'implementazione di test di unità efficaci;
        \item \textbf{Conformità ai principi SOLID:} La brevità dei metodi è spesso correlata al principio Single Responsibility Principle (SRP) dei principi SOLID, il che favorisce la costruzione di codice più modulare e coeso.
    \end{itemize} 
    \item \textbf{Lunghezza righe di codice}: mantenere le righe di codice entro i 80-120 caratteri permette una migliore leggibilità del codice su schermi di diverse dimensioni e facilita la visualizzazione di più file affiancati. Inoltre, limitare la lunghezza delle righe può incoraggiare la scrittura di codice più chiaro e modulare.
\end{itemize}

\paragraph{Commenti}
Evitare commenti superflui e non necessari: l'obiettivo è scrivere il codice in modo chiaro e autoesplicativo, riducendo la dipendenza da commenti esplicativi.

\subsubsection{Configurazione dell'ambiente di esecuzione}
\paragraph{Docker}

La scrittura dei file Docker è considerata parte del processo di sviluppo del software. \\
Le regole e le best practice di codifica per i file Docker sono fondamentali per garantire la creazione, la gestione e la distribuzione efficace dei container:
\begin{itemize}
    \item \textbf{Chiarezza e Coerenza:}
    \begin{itemize}
        \item Utilizzare nomi descrittivi per le immagini e i container.
        \item Mantenere una struttura coerente e consistente per assicurare un'organizzazione uniforme all'interno dei file Docker.
    \end{itemize}

\item \textbf{Versionamento:}
    \begin{itemize}
        \item Specificare sempre la versione dell'immagine di base (base image) per garantire la riproducibilità.
        \item Evitare di utilizzare tag "latest" per immagini di produzione.
    \end{itemize}

\item \textbf{Minimizzazione degli strati (Layering):}
    \begin{itemize}
        \item Ridurre il numero di istruzioni nell'esecuzione del Dockerfile per minimizzare gli strati dell'immagine.
        \item Raggruppare le istruzioni correlate per sfruttare la cache Docker.
    \end{itemize}

\item \textbf{Sicurezza:}
    \begin{itemize}
        \item Utilizzare immagini ufficiali o verificate.
        \item Evitare di eseguire processi Docker con privilegi elevati quando possibile.
        \item Usare ARG per parametrizzare informazioni sensibili.
    \end{itemize}

\item \textbf{Ottimizzazione delle risorse:}
    \begin{itemize}
        \item Limitare l'uso di risorse all'interno dei container (CPU, memoria, etc.).
        \item Usare immagini leggere e ottimizzate per la produzione.
    \end{itemize}

\item \textbf{Gestione delle variabili d'ambiente:}
    \begin{itemize}
        \item Usare variabili d'ambiente per configurazioni dinamiche.
        \item Fornire valori predefiniti opportuni per le variabili d'ambiente.
    \end{itemize}

\item \textbf{Logging e monitoraggio:}
    \begin{itemize}
        \item Configurare i container per registrare i log in modo efficace.
        \item Integrare strumenti di monitoraggio, se necessario.
    \end{itemize}

\item \textbf{Pulizia e riduzione delle dimensioni:}
    \begin{itemize}
        \item Pulire i pacchetti temporanei e le risorse non necessarie dopo l'installazione delle dipendenze.
        \item Ridurre le dimensioni delle immagini utilizzando multi-stage builds.
    \end{itemize}

\item \textbf{Documentazione:}
    \begin{itemize}
        \item Aggiungere commenti nel Dockerfile per spiegare le decisioni di progettazione.
        \item Fornire una documentazione chiara su come utilizzare e configurare il container.
    \end{itemize}

\item \textbf{Testing:}
    \begin{itemize}
        \item Implementare test automatizzati per il Dockerfile e i container, se possibile.
    \end{itemize}
\end{itemize}
\paragraph{Strumenti}
\begin{itemize}
    \item \textbf{VSCode}
    \item \textbf{Docker}
    \item \textbf{Git}
\end{itemize}

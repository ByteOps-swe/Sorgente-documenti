\begin{comment}
    \subsection{Comunicazione tra i componenti}
Nel contesto di \textit{Docker}\textsubscript{\textit{G}}, la comunicazione tra i \textit{container}\textsubscript{\textit{G}} avviene tramite la \textit{rete}\textsubscript{\textit{G}} \textit{Docker}\textsubscript{\textit{G}} interna, che è una \textit{rete}\textsubscript{\textit{G}} virtuale creata automaticamente da \textit{Docker}\textsubscript{\textit{G}} per i servizi all'interno di uno stesso file Compose o di un ambiente \textit{Docker}\textsubscript{\textit{G}}. Questa \textit{rete}\textsubscript{\textit{G}} consente ai \textit{container}\textsubscript{\textit{G}} di comunicare tra loro utilizzando i nomi dei servizi come hostnames.

Quando un \textit{container}\textsubscript{\textit{G}} viene avviato, \textit{Docker}\textsubscript{\textit{G}} assegna un hostname basato sul nome del \textit{servizio}\textsubscript{\textit{G}} definito nel file Compose. Ad esempio, nel file Compose fornito, il \textit{servizio}\textsubscript{\textit{G}} \textit{Kafka}\textsubscript{\textit{G}} ha il nome "\textit{kafka}\textsubscript{\textit{G}}" e il \textit{servizio}\textsubscript{\textit{G}} \textit{ClickHouse}\textsubscript{\textit{G}} ha il nome "\textit{clickhouse}\textsubscript{\textit{G}}". Questi nomi sono utilizzati all'interno dei \textit{container}\textsubscript{\textit{G}} stessi per identificare gli altri servizi. Quando un \textit{container}\textsubscript{\textit{G}} desidera comunicare con un altro \textit{container}\textsubscript{\textit{G}} sulla stessa \textit{rete}\textsubscript{\textit{G}} \textit{Docker}\textsubscript{\textit{G}}, può semplicemente utilizzare il nome del \textit{servizio}\textsubscript{\textit{G}} come hostname.

Inoltre, \textit{Docker}\textsubscript{\textit{G}} offre una funzionalità chiamata "Discovery", che consente ai \textit{container}\textsubscript{\textit{G}} di scoprire automaticamente gli altri \textit{container}\textsubscript{\textit{G}} sulla stessa \textit{rete}\textsubscript{\textit{G}} \textit{Docker}\textsubscript{\textit{G}} senza dover conoscere esplicitamente i loro indirizzi \textit{IP}\textsubscript{\textit{G}}. Questo semplifica la configurazione e la gestione della comunicazione tra i \textit{container}\textsubscript{\textit{G}}.

È anche possibile specificare dipendenze tra i servizi utilizzando l'attributo "depends\_on" nel file Compose. Questo assicura che un \textit{servizio}\textsubscript{\textit{G}} venga avviato solo dopo che i servizi di cui dipende sono stati avviati e sono nella condizione desiderata.

Infine, per i servizi che espongono porte, come \textit{Kafka}\textsubscript{\textit{G}}, \textit{ClickHouse}\textsubscript{\textit{G}} e \textit{Grafana}\textsubscript{\textit{G}}, è possibile mappare le porte del \textit{container}\textsubscript{\textit{G}} su porte del \textit{sistema}\textsubscript{\textit{G}} host utilizzando l'attributo "ports" nel file Compose. Questo consente ad altri componenti esterni al \textit{Docker}\textsubscript{\textit{G}} network di comunicare con i \textit{container}\textsubscript{\textit{G}} attraverso le porte esposte.

Quando un \textit{container}\textsubscript{\textit{G}} invia dati a un altro \textit{container}\textsubscript{\textit{G}} tramite la \textit{rete}\textsubscript{\textit{G}} \textit{Docker}\textsubscript{\textit{G}}, i dati vengono incapsulati in pacchetti di \textit{rete}\textsubscript{\textit{G}} utilizzando il protocollo TCP/\textit{IP}\textsubscript{\textit{G}}. Questi pacchetti vengono quindi instradati attraverso la \textit{rete}\textsubscript{\textit{G}} \textit{Docker}\textsubscript{\textit{G}}, che si occupa di consegnarli al destinatario corretto.

In sintesi, \textit{Docker}\textsubscript{\textit{G}} fornisce un'infrastruttura di \textit{rete}\textsubscript{\textit{G}} integrata che gestisce la comunicazione tra i \textit{container}\textsubscript{\textit{G}} all'interno dello stesso ambiente di deployment, semplificando la configurazione e la gestione della comunicazione tra i diversi componenti del \textit{sistema}\textsubscript{\textit{G}}.
\begin{itemize}
    \item \textbf{Comunicazione data feed Layer -> Streaming Layer}: Si utilizza libreria \textit{Confluent Kafka} per \textit{Python}\textsubscript{\textit{G}} che offre un'\textit{API}\textsubscript{\textit{G}} efficiente e flessibile per inviare dati dai simulatori dei sensori a specifici topic \textit{Kafka}\textsubscript{\textit{G}}.
    \item \textbf{Comunicazione Processing Layer -> Streaming Layer}: Si utilizza Faust come interfaccia di alto livello per la comunicazione con \textit{Kafka}\textsubscript{\textit{G}}. Faust offre un'interfaccia intuitiva e ben documentata per consumare dati da topic con flussi di dati in tempo reale.
    Ulteriori informazioni in: \ref{sec:faust}
    \item \textbf{Comunicazione Storage Layer -> Streaming Layer}: Per ottenere in tempo reale i dati dai topic \textit{kafka}\textsubscript{\textit{G}} viene utilizzato l'engine \textit{kafka}\textsubscript{\textit{G}} di \textit{Clickhouse}\textsubscript{\textit{G}}. Ulteriori informazioni in: \ref{sec:kafka_engine}
    \item \textbf{Comunicazione Data Visualization Layer-> Storage Layer}: \textit{Grafana}\textsubscript{\textit{G}} si connette a \textit{Clickhouse}\textsubscript{\textit{G}} per ottenere i dati da visualizzare in tempo reale tramite lo specifico plugin \textit{ClickHouse}\textsubscript{\textit{G}} che permette l'utilizzo di un \textit{database}\textsubscript{\textit{G}} \textit{Clickhouse}\textsubscript{\textit{G}} come \textit{data source}.
    Il plugin nasconde alcuni dettagli di implementazione sottostanti, come la gestione della connessione,protocolli di comunicazione e l'esecuzione delle \textit{query}\textsubscript{\textit{G}}. Ulteriori informazioni in: \ref{sec:click_plugin}
\end{itemize}


    
\subsubsection{Dipendenze tra i servizi}
\begin{itemize}
    \item \textbf{Clickhouse -> kafka}: Il \textit{servizio}\textsubscript{\textit{G}} \textit{ClickHouse}\textsubscript{\textit{G}} dipende dal \textit{servizio}\textsubscript{\textit{G}} \textit{Kafka}\textsubscript{\textit{G}}. Questo assicura che il \textit{servizio}\textsubscript{\textit{G}} \textit{ClickHouse}\textsubscript{\textit{G}} venga avviato solo dopo che il \textit{servizio}\textsubscript{\textit{G}} \textit{Kafka}\textsubscript{\textit{G}} è stato avviato e è nella condizione desiderata.

    \item \textbf{Simulators -> kafka}: Il \textit{servizio}\textsubscript{\textit{G}} Simulators dipende dal \textit{servizio}\textsubscript{\textit{G}} \textit{Kafka}\textsubscript{\textit{G}}. Questo assicura che il \textit{servizio}\textsubscript{\textit{G}} Simulators venga avviato solo dopo che il \textit{servizio}\textsubscript{\textit{G}} \textit{Kafka}\textsubscript{\textit{G}} è stato avviato e è nella condizione desiderata.
    
    \item \textbf{ Faust app -> kafka}: Il \textit{servizio}\textsubscript{\textit{G}} Processor dipende dal \textit{servizio}\textsubscript{\textit{G}} \textit{Kafka}\textsubscript{\textit{G}}. Questo assicura che il \textit{servizio}\textsubscript{\textit{G}} Processor venga avviato solo dopo che il \textit{servizio}\textsubscript{\textit{G}} \textit{Kafka}\textsubscript{\textit{G}} è stato avviato e è nella condizione desiderata.
\end{itemize}

\end{comment}
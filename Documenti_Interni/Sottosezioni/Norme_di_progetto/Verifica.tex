\subsection{Verifica}
\label{subsec:verifica}

\subsubsection{Introduzione}
La verifica è un processo essenziale che accompagna l'intero ciclo di vita del \textit{software}\textsubscript{\textit{G}}, partendo dalla fase di progettazione fino alla manutenzione. \\
Il suo obiettivo principale è garantire l'efficienza e la correttezza delle \textit{attività}\textsubscript{\textit{G}}, istanziando per ciascun prodotto un processo di verifica mirato a garantire risultati conformi alle aspettative. Questo processo si avvale di tecniche di analisi e \textit{test}\textsubscript{\textit{G}} per assicurare che i prodotti soddisfino i requisiti specificati.

\vspace{0.2cm}

Per assicurare il corretto svolgimento della verifica, è fondamentale seguire alcune linee guida chiave, tra cui l'utilizzo di criteri affidabili e di procedure ben definite. Questo assicura che il prodotto si trovi in uno stato stabile, pronto per passare alla successiva fase di validazione.

\vspace{0.2cm}

La verifica viene eseguita su tutti i \textit{processi}\textsubscript{\textit{G}} in esecuzione, quando si raggiunge un adeguato livello di maturità o in seguito a modifiche dello stato del processo. Durante questa fase, si analizza la qualità dei prodotti e dei \textit{processi}\textsubscript{\textit{G}} utilizzati per garantire la conformità agli \textit{standard}\textsubscript{\textit{G}} di qualità definiti.

\vspace{0.2cm}

Le \textit{attività}\textsubscript{\textit{G}} di verifica sono assegnate a verificatori, i quali, seguendo l'ordine definito nel modello a V, analizzano i prodotti e valutano la loro conformità ai requisiti di qualità specificati nel \textit{Piano di Qualifica}.

\vspace{0.2cm}

È fondamentale documentare nel \textit{Piano di Qualifica} tutte le \textit{attività}\textsubscript{\textit{G}} che compongono il processo di verifica, descrivendone gli obiettivi, i risultati attesi e quelli ottenuti. Questo fornisce linee guida per una valutazione accurata della qualità, normando e rendendo ripetibile il processo di verifica.

\subsubsection{Verifica dei documenti}
\label{sec:verificatori}

Il ruolo del verificatore nei documenti è cruciale per garantire la qualità e l'accuratezza del contenuto. 

Quando il verificatore individua un'Issue nella colonna "Da revisionare" della \href{https://github.com/orgs/ByteOps-swe/projects/1/views/1}{DashBoard documentazione}, sarà tenuto a convalidare il file corrispondente presente nella \textit{repository}\textsubscript{\textit{G}} \href{https://github.com/ByteOps-swe/Sorgente-documenti}{Sorgente documenti}.

In aggiunta, il revisore riceverà una notifica via email quando il redattore completa la propria \textit{attività}\textsubscript{\textit{G}}, comunicandogli la presenza della Pull Request assegnatagli.

Nella sezione "Pull requests" di GitHub, il revisore troverà la richiesta di unire il \textit{branch}\textsubscript{\textit{G}} di redazione al \textit{branch}\textsubscript{\textit{G}} "main". Accedendo alla Pull Request su GitHub, il revisore avrà la possibilità di esaminare attentamente il documento in questione.

Durante questa revisione, il revisore potrà aggiungere commenti direttamente sul documento, fornendo feedback e suggerimenti ai redattori per eventuali modifiche necessarie per la validazione. I commenti aggiunti saranno visibili ai redattori, consentendo loro di comprendere le richieste di revisione e apportare le modifiche richieste. Questo processo collaborativo facilita il flusso di lavoro di revisione e garantisce la qualità e l'accuratezza del documento finale.

\vspace{0.3cm}

Per validare un documento le verifiche da attuare sono:
\begin{itemize}
    \item \textbf{Revisione della correttezza tecnica:} 
        eseguire una revisione tecnica del documento per garantire che tutte le informazioni siano corrette, coerenti e rispettino le norme stabilite; 
    \item \textbf{Conformità alle norme:} 
        verificare che il documento segua le linee guida e gli \textit{standard}\textsubscript{\textit{G}} prestabiliti per la formattazione, la struttura e lo stile; 
    \item \textbf{Consistenza e coerenza:} 
        assicurarsi che il documento sia consistente internamente e coerente con altri documenti correlati. Verificare che non ci siano discrepanze o contraddizioni;
    \item \textbf{Chiarezza e comprensibilità:} 
        valutare la chiarezza del testo, assicurandosi che il linguaggio sia comprensibile per il pubblico di destinazione e che non ci siano ambiguità;
    \item \textbf{Revisione grammaticale e ortografica:} 
        controllare la grammatica, l'ortografia e la punteggiatura del documento per garantire una presentazione professionale;
\end{itemize}

Dopo aver accertato il rispetto dei criteri sopra citati, qualora fossero soddisfatti, il procedimento per convalidare il documento è il seguente:

\begin{enumerate}
    \item \textbf{Accetta la Pull Request:} 
        accedere alla pagina della Pull Request in cui si agirà con il ruolo di revisore nel \textit{repository}\textsubscript{\textit{G}} \href{https://github.com/ByteOps-swe/Sorgente-documenti}{Sorgente-documenti} su GitHub >> Risolvere eventuali conflitti >> Merge Pull Request;
    \item \textbf{Elimina il branch:} 
        eliminare il \textit{branch}\textsubscript{\textit{G}} creato per la redazione del documento (o sezione);
    \item \textbf{Sposta la issue in Done:} 
        nella \href{https://github.com/orgs/ByteOps-swe/projects/1/views/1}{DashBoard documentazione} spostare la \textit{issue}\textsubscript{\textit{G}} relativa al documento validato dalla sezione "Da revisionare" a "Done";
    \item \textbf{Controllo generazione PDF:} 
        un'automazione tramite GitHub Actions compilerà il file \LaTeX\ e genererà automaticamente il PDF nel \textit{branch}\textsubscript{\textit{G}} main della \textit{repository}\textsubscript{\textit{G}} \href{https://github.com/ByteOps-swe/Documents}{Documents} con la data di redazione nel caso il documento sia un verbale, oppure la versione aggiornata per tutte le altre tipologie di file. \\
        Se la procedura di compilazione dovesse fallire, il verificatore riceverà automaticamente una notifica via mail e dovrà accedere alla sezione "Actions" di GitHub per esaminare l'origine dell'errore e intraprendere le azioni necessarie per correggerlo.
\end{enumerate}

\subsubsection{Analisi}
Attività di controllo su oggetti statici (documentazione, codice) e dinamici (componenti \textit{software}\textsubscript{\textit{G}}).

\paragraph{Analisi statica}
Questo genere di analisi prende il nome di "statica" proprio perché viene condotta sul prodotto senza la necessità di eseguirlo. \\ L'efficacia di questa pratica dipende in modo diretto dall'esperienza e dalla competenza dei verificatori coinvolti. Essa coinvolge l'utilizzo di metodi di lettura, sia manuali che automatici, volti a individuare eventuali errori formali come violazione di vincoli, presenza di difetti e manifestazione di proprietà indesiderate nel prodotto in questione. \\
Le due principali tecniche impiegate sono:

\paragraph{Walkthrough}
Il verificatore controlla nella totalità il prodotto in cerca di difetti o errori, senza svolgere una ricerca specifica per un certo tipo di errore. Questa metodologia implica appunto una verifica approfondita della documentazione e del codice attraverso un'analisi sistematica. Si promuove la collaborazione e l'interazione tra il verificatore e l'autore del prodotto, strutturata nei seguenti quattro passaggi:

\begin{enumerate}
    \item \textbf{Pianificazione:} 
        una fase di dialogo tra gli autori e i verificatori, finalizzata all'identificazione delle proprietà e dei vincoli che il prodotto deve soddisfare per essere considerato corretto; 

    \item \textbf{Lettura:} 
        il verificatore esamina attentamente i documenti e/o il codice, individuando errori e verificando la conformità ai vincoli prestabiliti; 

    \item \textbf{Discussione:} 
        successivo confronto tra autori e verificatori per discutere l'esito della lettura e valutare eventuali correzioni necessarie; 

    \item \textbf{Correzione:} 
        \textit{attività}\textsubscript{\textit{G}} assegnata agli autori per correggere gli errori individuati nei passaggi precedenti.
\end{enumerate}

Questo metodo di verifica sarà prevalentemente adottato nelle fasi iniziali del progetto, in quanto i prodotti soggetti a verifica saranno generalmente meno complessi e, di conseguenza, l'operazione risulterà più agevole e meno dispendiosa in termini di risorse.

Le \textit{attività}\textsubscript{\textit{G}} in cui verrà applicata la tecnica del Walkthrough sono:
\begin{itemize}
    \item \textbf{Revisione dei requisiti:} 
        per assicurarsi che tutti i requisiti siano chiari, comprensibili e conformi alle esigenze del cliente;
    \item \textbf{Codifica del software:} 
        per identificare errori di logica, pratiche non ottimali o potenziali problemi di manutenibilità nel codice;
    \item \textbf{Documentazione tecnica:} 
        per assicurarsi che la documentazione tecnica sia accurata, chiara e completa. 
\end{itemize}

\paragraph{Inspection}
L'obiettivo di questa tecnica consiste nel rilevare eventuali difetti nel prodotto in esame mediante un'analisi mirata, piuttosto che tramite una revisione completa che non tende ad individuare dei difetti specifici.

\vspace{0.2cm}

Tale approccio prevede la specifica preventiva degli elementi da verificare, i quali vengono organizzati in liste di controllo.
Queste liste fungono da \textit{checklist} per valutare l'accuratezza dell'\textit{attività}\textsubscript{\textit{G}} d'ispezione, determinando se è stata condotta in modo corretto.L'inspection risulta particolarmente vantaggiosa quando ci si trova di fronte a documenti o codice complessi e strutturati, specialmente nelle fasi avanzate del progetto.

In questo contesto, il processo di verifica tramite inspection si rivela più efficace rispetto a un walkthrough, poiché quest'ultimo richiederebbe un considerevole impiego di risorse.

\paragraph{Analisi dinamica}
Nel processo di sviluppo \textit{software}\textsubscript{\textit{G}}, è essenziale condurre una verifica accurata del codice prodotto al fine di garantirne il corretto funzionamento. Questo processo si avvale dell'analisi dinamica, una categoria di metodologie di analisi che richiedono l'esecuzione effettiva del prodotto.

\vspace{0.2cm}

L'analisi dinamica coinvolge l'esecuzione di una serie di casi di \textit{test}\textsubscript{\textit{G}} durante l'attuazione del codice. L'obiettivo di tali \textit{test}\textsubscript{\textit{G}} è assicurare l'esecuzione accurata del \textit{software}\textsubscript{\textit{G}} e individuare eventuali discordanze tra i risultati ottenuti e quelli previsti. 

\vspace{0.2cm}

È importante sottolineare che l'analisi dinamica non è applicabile alla documentazione.
Per assicurare l'efficacia dell'analisi dinamica, è necessario automatizzare e rendere ripetibile questo processo, garantendo così una valutazione oggettiva del prodotto.

Nel contesto dell'ingegneria del \textit{software}\textsubscript{\textit{G}}, il \textit{test}\textsubscript{\textit{G}} rappresenta la principale tecnica di analisi dinamica.

\subsubsection{Testing}
\label{subsubsec:Testing}
L'obiettivo del testing è assicurare il corretto funzionamento della componente soggetta al \textit{test}\textsubscript{\textit{G}}, verificando che produca i risultati attesi e che rispetti accuratamente i vincoli assegnati. Questi \textit{test}\textsubscript{\textit{G}} sono inoltre strumentali per individuare eventuali anomalie di funzionamento. \\
Per ciascun \textit{test}\textsubscript{\textit{G}}, è essenziale definire i seguenti parametri:

\begin{itemize}
    \item \textbf{Ambiente:} 
        il \textit{sistema}\textsubscript{\textit{G}} (hardware e \textit{software}\textsubscript{\textit{G}}) utilizzato per eseguire il \textit{test}\textsubscript{\textit{G}};
    \item \textbf{Stato iniziale:} 
        i parametri del \textit{software}\textsubscript{\textit{G}} al momento dell'esecuzione del \textit{test}\textsubscript{\textit{G}};
    \item \textbf{Input:} 
        i dati forniti in entrata per l'esecuzione del \textit{test}\textsubscript{\textit{G}};
    \item \textbf{Output:} 
        i risultati attesi in uscita in relazione a uno specifico input;
    \item \textbf{Commenti addizionali:} 
        eventuali osservazioni o annotazioni aggiuntive pertinenti al \textit{test}\textsubscript{\textit{G}}.
\end{itemize}
Tali \textit{test}\textsubscript{\textit{G}} andranno poi automatizzati. 

\paragraph{Test di unità}
Questi \textit{test}\textsubscript{\textit{G}} sono progettati per verificare singole unità di codice, come funzioni o metodi, in modo isolato e indipendente dal resto del \textit{sistema}\textsubscript{\textit{G}}. L'obiettivo principale dei \textit{test}\textsubscript{\textit{G}} di unità è garantire che ogni unità di codice funzioni correttamente, conformandosi alle specifiche e restituendo i risultati attesi.

Tali \textit{test}\textsubscript{\textit{G}} si prestano quindi ad un alto grado di parallelismo, essi vengono pianificati durante la progettazione di dettaglio.
Devono essere eseguiti per primi, in quanto verificano l’integrità e la correttezza della singola unità, prima dell’\textit{integrazione}\textsubscript{\textit{G}} con le altre. 

\vspace{0.2cm}

Per implementare tali \textit{test}\textsubscript{\textit{G}}, è consentito l'utilizzo di oggetti simulati o parziali, come mock e stub, al fine di separare l'unità di codice in esame dalle sue dipendenze esterne. Questo approccio permette di verificare il comportamento dell'unità in contesti controllati, garantendo un'efficace isolamento durante le fasi di \textit{test}\textsubscript{\textit{G}}.

\vspace{0.2cm}

Un ulteriore obiettivo dei \textit{test}\textsubscript{\textit{G}} di unità consiste nel verificare la massima copertura possibile dei percorsi all'interno dell'unità. A tal fine, vengono appositamente progettati per attivare specifici percorsi, creando così una serie di \textit{test}\textsubscript{\textit{G}} dedicati che devono garantire una copertura completa del codice dell'unità, generando in tal modo la "structural coverage".
 
\paragraph{Test di integrazione}
I \textit{test}\textsubscript{\textit{G}} di \textit{integrazione}\textsubscript{\textit{G}} sono una fase essenziale nell'analisi dinamica del \textit{software}\textsubscript{\textit{G}} e mirano a verificare il corretto funzionamento delle diverse unità di codice quando sono integrate per formare una componente più ampia o l'intero \textit{sistema}\textsubscript{\textit{G}}. 

\vspace{0.2cm}

Questa fase si concentra sull'interazione tra le parti del \textit{software}\textsubscript{\textit{G}} per garantire che lavorino sinergicamente secondo le specifiche del progetto.

I \textit{test}\textsubscript{\textit{G}} di \textit{integrazione}\textsubscript{\textit{G}} vengono pianificati durante la fase di progettazione architetturale e possono avere un approccio: 

\begin{itemize}
    \item \textbf{Top-down:}
        l'\textit{integrazione}\textsubscript{\textit{G}} inizia con le componenti di \textit{sistema}\textsubscript{\textit{G}} che presentano maggiori dipendenze e un maggiore valore esterno, consentendo la tempestiva disponibilità delle funzionalità di alto livello. Ciò consente di effettuare \textit{test}\textsubscript{\textit{G}} prolungati sulle funzionalità principali, rendendole disponibili inizialmente ma richiede molti mock;
    \item \textbf{Bottom-up:}
        l'\textit{integrazione}\textsubscript{\textit{G}} ha inizio dalle componenti di \textit{sistema}\textsubscript{\textit{G}} caratterizzate da minori dipendenze e un maggiore valore interno, ossia quelle meno visibili all'utente. Questo implica la necessità di meno mock ma ritarda il \textit{test}\textsubscript{\textit{G}} delle funzionalità utente esponendole per minor tempo a verifica.
\end{itemize}

Il team svolgerà, ove possibile, \textit{test}\textsubscript{\textit{G}} di \textit{integrazione}\textsubscript{\textit{G}} con l'approccio "Top down". 

\paragraph{Test di sistema}
Questi \textit{test}\textsubscript{\textit{G}} sono progettati per verificare l'intero \textit{sistema}\textsubscript{\textit{G}} \textit{software}\textsubscript{\textit{G}} rispetto ai requisiti specificati, garantendo che tutte le componenti siano integrate correttamente e che l'applicazione esegua le funzioni previste in modo accurato e affidabile. 

\vspace{0.2cm}

In particolare devono essere implementati: 
\begin{itemize}
    \item \textbf{Test End-to-End:} 
        coinvolgono l'esecuzione completa del \textit{sistema}\textsubscript{\textit{G}}, dalla sua interfaccia utente fino alle componenti di backend, al fine di simulare l'esperienza completa dell'utente.
\end{itemize} 

I \textit{test}\textsubscript{\textit{G}} di \textit{sistema}\textsubscript{\textit{G}} vengono eseguiti dopo che sono stati completati con successo i \textit{test}\textsubscript{\textit{G}} di \textit{integrazione}\textsubscript{\textit{G}}. 

\paragraph{Test di regressione}
Mirano a garantire che le modifiche apportate al codice non abbiano introdotto nuovi difetti o compromesso le funzionalità preesistenti del \textit{sistema}\textsubscript{\textit{G}}. 

Questi \textit{test}\textsubscript{\textit{G}} sono essenziali per assicurare che le modifiche al \textit{software}\textsubscript{\textit{G}} non causino regressioni, ovvero la ricomparsa di errori precedentemente risolti o la compromissione di funzionalità precedentemente funzionanti. 

I \textit{test}\textsubscript{\textit{G}} di regressione devono essere eseguiti ogni volta che vengono apportate modifiche al codice, garantendo una verifica continua e automatica della stabilità del \textit{sistema}\textsubscript{\textit{G}}. 

\paragraph{Test di accettazione}
I \textit{test}\textsubscript{\textit{G}} di accettazione sono un passo fondamentale prima del rilascio del \textit{software}\textsubscript{\textit{G}} e sono progettati per garantire che il prodotto finale sia in grado di soddisfare le aspettative degli utenti finali e che risponda in modo appropriato ai requisiti specificati. 

\paragraph{Sequenza delle fasi di test}
La sequenza delle fasi di \textit{test}\textsubscript{\textit{G}} è la seguente:

\begin{enumerate}
    \item Test di Unità;
    \item Test di Integrazione;
    \item Test di Regressione;
    \item Test di Sistema;
    \item Test di accettazione.
\end{enumerate}

\paragraph{Codici dei test}
Per classificare ogni \textit{test}\textsubscript{\textit{G}} che il team effettuerà durante l'\textit{attività}\textsubscript{\textit{G}} di verifica abbiamo deciso di associare un codice identificativo per ciascun \textit{test}\textsubscript{\textit{G}} nel formato: 

\begin{center}
    \textbf{T [tipo] [codice]}
\end{center}
dove:

\begin{itemize}
    \item \textbf{[tipo]:} 
        \begin{itemize}
            \item \textbf{U:} 
                \textit{test}\textsubscript{\textit{G}} di unità;
            \item \textbf{I:} 
                \textit{test}\textsubscript{\textit{G}} di \textit{integrazione}\textsubscript{\textit{G}};
            \item \textbf{S:} 
                \textit{test}\textsubscript{\textit{G}} di \textit{sistema}\textsubscript{\textit{G}};
            \item \textbf{R:} 
                \textit{test}\textsubscript{\textit{G}} di regressione;
            \item\textbf{A:} 
                \textit{test}\textsubscript{\textit{G}} di accettazione.
        \end{itemize}
    \item \textbf{[codice]:} 
        è un numero associato al \textit{test}\textsubscript{\textit{G}} all'interno del suo tipo: 
        \begin{itemize}
            \item 
                se il \textit{test}\textsubscript{\textit{G}} non ha un padre, è un semplice numero progressivo;
            \item 
                se il \textit{test}\textsubscript{\textit{G}} ha un padre, sarà nel formato:
                \begin{center}
                    \textbf{[codice.padre] . [codice.figlio]} 
                \end{center}
                con:
                \begin{itemize}
                    \item \textbf{[codice.padre] :} 
                        identifica in maniera univoca il padre del \textit{test}\textsubscript{\textit{G}} all'interno della categoria di \textit{test}\textsubscript{\textit{G}} relativi al suo tipo;
                    \item \textbf{[codice.figlio] :} 
                        numero progressivo per identificare il \textit{test}\textsubscript{\textit{G}}.
                \end{itemize}
        \end{itemize}
\end{itemize}

\paragraph{Stato dei test}
Ad ogni \textit{test}\textsubscript{\textit{G}} sarà assegnato uno stato che rifletterà il risultato della sua esecuzione. \\
I risultati dei \textit{test}\textsubscript{\textit{G}} saranno registrati nel documento "\textit{Piano di Qualifica}", all'interno della sezione "\textit{Specifica dei test}".

\vspace{0.2cm}

Ogni \textit{test}\textsubscript{\textit{G}} potrà assumere uno dei seguenti stati:

\begin{itemize}
    \item \textbf{NI:} 
        il \textit{test}\textsubscript{\textit{G}} non è ancora stato implementato (Non implementato); 
    \item \textbf{S:} 
        il \textit{test}\textsubscript{\textit{G}} ha riportato esito positivo (Superato); 
    \item \textbf{NS:}
        il \textit{test}\textsubscript{\textit{G}} ha riportato esito negativo (Non Superato).
\end{itemize}

\paragraph{Continuous Integration}
L'integrazione continua (CI) è una pratica di sviluppo software che automatizza l'integrazione frequente del codice sorgente da parte degli sviluppatori. Invece di attendere il completamento di grandi porzioni di lavoro o addirittura il rilascio finale, gli sviluppatori integrano il loro codice in un ramo principale condiviso più volte al giorno, solitamente dopo aver completato piccole modifiche.

\vspace{0.2cm}

Il processo di CI, che nel nostro progetto è implementato per la repo di MVP, è innescato dalla creazione di un Pull Request, quando uno dei programmatori vuole integrare le modifiche fatte con il ramo principale della repo. Tale Pull Request viene effettuata una volta che il programmatore ha finito di completare:

\begin{itemize}
    \item \textbf{Implementazione di Feature};
    \item \textbf{Creazione di Test};
    \item \textbf{Refactoring};
    \item \textbf{Risoluzione di Bug}.
\end{itemize}

Con la creazione di una Pull Request, avviene l'innesco di un applicazione di GitHub, chiamato Codacy, che esegue test di tipo statico. Tale applicazione da esito positivo, nella pagina della Pull Request, se le modifiche fatte non hanno introdotto codice non conforme alle regole di analisi statica definite. Se l'applicazione da un esito di fallimento, il programmatore deve cambiare le modifiche finché il codice passa l'analisi statica.

\vspace{0.2cm}

Alla conclusione della Pull Request con successo, tramite i workflow di GitHub, il codice del prodotto viene ottenuto e inizia la parte di build del prodotto. In questa parte, tramite il commando:
\begin{lstlisting}[style=code]
    docker compose up
\end{lstlisting}
viene effettuato il pull da DockerHub di tutte le immagini necessarie per costruire tutti in componenti del prodotto.

\vspace{0.2cm}

Una volta conclusa la costruzione dell prodotto con successo inizia la parte di testing statica e dinamica grazie ad un profilo di testing dell'ambiente Docker. Prima di tutto, iniziano i test statici usando Pylint. L'esito di tali test viene nel file \textit{README.md} usando un badge di GitHub.

\vspace{0.2cm}

Una volta finiti i test statici iniziano i test dinamici che sono:

\begin{itemize}
    \item \textbf{Test di Unita};
    \item \textbf{Test di Integrazione};
    \item \textbf{Test di Sistema}.
\end{itemize}

Alla conclusione dei test viene riportato il code coverage in un file chiamato coverage.xml. Questo file grazie a GitHub action viene ottenuto e i risultati vengono trasformati in badge di GitHub che vengono aggiunti nel file \textit{README.md}.
che poi aggiornano i rispettati badge di GitHub nella file README.md.


\hypertarget{subsubsec:strumentiVerifica}{\subsubsection{Strumenti}}
\begin{itemize}
    \item \textbf{Spell checker:} 
        controllo ortografico integrato nell’ambiente di lavoro;
    \item \textbf{Modulo "pytest" Python:} libreria \textit{standard}\textsubscript{\textit{G}} che offre una serie di funzionalità per creare, organizzare e eseguire \textit{test}\textsubscript{\textit{G}} di unità in modo efficace e automatizzato;
    \item \textbf{Modulo "Pylint" Python:} libreria open source che analizza il codice sorgente Python per identificare potenziali errori, bug e cattive abitudini di programmazione;
    \item \textbf{Applicazione GitHub Codacy:} servizio che verifica il codice tramite l'analisi statica;
    \item \textbf{\href{https://github.com/marketplace/actions/coveralls-github-action}{Coverallas}:} servizio che traccia e mostra il code coverage;
    \item \textbf{\href{https://github.com/marketplace/actions/codecov}{Codecov}:} servizio che traccia e mostra il code coverage;
\end{itemize}
